<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Types" #>
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using ExhaustiveMatching;

namespace <#=tree.Namespace #>;

[GeneratedCode("AzothCompilerCodeGen", null)]
public static class <#=Emit.TypeName(tree.Root)#>Extensions
{
    [DebuggerStepThrough]
    public static IEnumerable<<#=Emit.TypeName(tree.Root)#>> Children(this <#=Emit.TypeName(tree.Root)#> node)
    {
        switch (node)
        {
            default:
                throw ExhaustiveMatch.Failed(node);
<#  foreach(var rule in tree.Rules.Where(r => !r.IsAbstract)) { #>
            case <#=Emit.TypeName(rule.Defines) #> n:
<#      foreach(var property in rule.DeclaredProperties.Where(p => p.ReferencesRule)) { #>
<#          if (property.Type is CollectionType) { #>
                foreach (var child in n.<#=property.Name #>)
                    yield return child;
<#          } else if (property.Type is OptionalType) { #>
                if (n.<#=property.Name #> is not null)
                    yield return n.<#=property.Name #>;
<#          } else { #>
                yield return n.<#=property.Name #>;
<#          } #>
<#      } #>
                yield break;
<#  } #>
        }
    }
}
