<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Attributes" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Equations" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Syntax.Equations" #>
<#  foreach(var usingNamespace in Build.OrderedNamespaces(tree,
    !tree.SimplifiedTree, new [] { "System", "System.Linq", "System.Threading", "Azoth.Tools.Bootstrap.Compiler.Core.Attributes" },
    "ExhaustiveMatching", "System.CodeDom.Compiler", "System.Diagnostics")) { #>
using <#=usingNamespace #>;
<#  } #>

namespace <#=tree.Namespace #>;

// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable RedundantTypeDeclarationBody
// ReSharper disable ReturnTypeCanBeNotNullable
// ReSharper disable ConvertToPrimaryConstructor

<#  foreach(var node in tree.Nodes) {#>
<#=Emit.ClosedAttribute(node) #>[GeneratedCode("AzothCompilerCodeGen", null)]
public partial interface <#= Emit.TypeName(node.Defines) #><#= Emit.BaseTypes(node) #>
{
<#      foreach (var attribute in node.AttributesRequiringDeclaration) { #>
<#          switch (attribute) { #>
<#              case PropertyModel: #>
<#              case InheritedAttributeModel: #>
    <#= Emit.IsNew(attribute) #><#= Emit.Type(attribute.Type) #> <#= attribute.Name #> { get; }
<#                  break;#>
<#              case SynthesizedAttributeModel attr: #>
    <#=Emit.IsNew(attr) #><#=Emit.Type(attr.Type) #> <#=attr.Name #><#=attr.Parameters #><#=Emit.Body(attr) #>
<#                  break;#>
<#          } #>
<#          foreach (var baseAttribute in Build.BaseAttributes(node, attribute)) { #>
    <#=Emit.Type(baseAttribute.Type) #> <#= Emit.TypeName(baseAttribute.Node.Defines) #>.<#=baseAttribute.Name #> => <#=attribute.Name #>;
<#          } #>
<#      } #>
<#      if (tree.GenerateClasses && !node.IsAbstract) { #>

    public static <#= Emit.TypeName(node.Defines) #> Create(<#=string.Join(", ", node.ActualProperties.Select(p => $"{Emit.Type(p.Type)} {Emit.ParameterName(p)}")) #>)
        => new <#= Emit.ClassName(node.Defines) #>(<#=string.Join(", ", node.ActualProperties.Select(p => Emit.ParameterName(p))) #>);
<#      } #>
}

<#  } #>
<#  if (tree.GenerateClasses) { #>
<#  if (!tree.SimplifiedTree) { #>
// TODO switch back to `file` and not `partial` once fully transitioned
internal abstract partial class <#= Emit.BaseClassName(tree) #> : TreeNode, IChildTreeNode<<#= Emit.TypeName(tree.RootSupertype) #>>
{
    private <#= Emit.BaseClassName(tree) #>? parent;

    protected <#= Emit.BaseClassName(tree) #>() { }
    protected <#= Emit.BaseClassName(tree) #>(bool inFinalTree) : base(inFinalTree) { }

    [DebuggerStepThrough]
    protected sealed override ITreeNode PeekParent()
        // Use volatile read to ensure order of operations as seen by other threads
        => Volatile.Read(in parent) ?? throw Child.ParentMissing(this);

    protected <#= Emit.BaseClassName(tree) #> GetParent(IInheritanceContext ctx)
    {
        // Use volatile read to ensure order of operations as seen by other threads
        var node = Volatile.Read(in parent) ?? throw Child.ParentMissing(this);
        ctx.AccessParentOf(this);
        return node;
    }

    void IChildTreeNode<<#= Emit.TypeName(tree.RootSupertype) #>>.SetParent(<#= Emit.TypeName(tree.RootSupertype) #> newParent)
    {
        if (newParent is not <#= Emit.BaseClassName(tree) #> newParentNode)
            throw new ArgumentException($"Parent must be a {nameof(<#= Emit.BaseClassName(tree) #>)}.", nameof(newParent));

        // Use volatile write to ensure order of operations as seen by other threads
        Volatile.Write(ref parent, newParentNode);
    }

    /// <summary>
    /// The previous node to this one in a preorder traversal of the tree.
    /// </summary>
    protected virtual <#= Emit.BaseClassName(tree) #> Previous(IInheritanceContext ctx)
    {
        <#= Emit.BaseClassName(tree) #>? previous = null;
        var parent = GetParent(ctx);
        foreach (var child in parent.Children().Cast<<#= Emit.BaseClassName(tree) #>>())
        {
            if (child == this)
                // If this is the first child, return the parent without descending
                return previous?.LastDescendant() ?? parent;
            previous = child;
        }

        throw new UnreachableException("Node is not a child of its parent.");
    }

    // TODO can this be more efficient?
    internal <#= Emit.BaseClassName(tree) #> LastDescendant()
        => ((<#= Emit.BaseClassName(tree) #>?)Children().LastOrDefault())?.LastDescendant() ?? this;
<#      foreach (var attr in tree.AllAttributeSupertypes) { #>

    internal virtual <#= Emit.Type(attr.Type) #> Inherited<#= attr.Name #>(<#= Emit.BaseClassName(tree) #> child, <#= Emit.BaseClassName(tree) #> descendant, IInheritanceContext ctx)
        // TODO does this need to throw an exception for the root of the tree?
        => GetParent(ctx).Inherited<#= attr.Name #>(this, descendant, ctx);
    protected <#= Emit.Type(attr.Type) #> Inherited<#= attr.Name #>(IInheritanceContext ctx)
        => GetParent(ctx).Inherited<#= attr.Name #>(this, this, ctx);
<#      } #>
}

<#  } #>
<#  foreach(var node in tree.Nodes.Where(ShouldEmit.Class)) {#>
[GeneratedCode("AzothCompilerCodeGen", null)]
file class <#= Emit.ClassName(node.Defines) #> : <#= Emit.BaseClass(tree) #><#= Emit.TypeName(node.Defines) #>
{
<#      foreach (var property in node.ActualProperties) { #>
    public <#= Emit.Type(property.Type) #> <#= property.Name #> { [DebuggerStepThrough] get; }
<#      } #>
<#      foreach (var attr in node.ActualAttributes.OfType<InheritedAttributeModel>()) { #>
    public <#= Emit.Type(attr.Type) #> <#= attr.Name #><#= Emit.Parameters(attr) #><#= Emit.Body(attr) #>
<#      } #>
<#      foreach (var equation in node.ActualEquations) { #>
<#          switch (equation) { #>
<#              case SynthesizedAttributeEquationModel eq when eq.Strategy == EvaluationStrategy.Eager: #>
    public <#= Emit.Type(eq.Type) #> <#= eq.Name #> { [DebuggerStepThrough] get; }
<#                  break;#>
<#              case SynthesizedAttributeEquationModel eq when eq.Strategy != EvaluationStrategy.Eager: #>
    public <#= Emit.Override(eq) #><#= Emit.Type(eq.Type) #> <#= eq.Name #><#= eq.Parameters #><#= Emit.Body(eq) #>
<#                  break;#>
<#          } #>
<#      } #>

    public <#= Emit.ClassName(node.Defines) #>(<#=string.Join(", ", node.ActualProperties.Select(p => $"{Emit.Type(p.Type)} {Emit.ParameterName(p)}")) #>)
    {
<#      foreach (var property in node.ActualProperties) { #>
        <#=property.Name #> = <#=Emit.ParameterName(property) #>;
<#      } #>
<#      foreach (var equation in node.ActualEquations.OfType<SynthesizedAttributeEquationModel>().Where(eq => eq.Strategy == EvaluationStrategy.Eager)) { #>
        <#= equation.Name #> = <#= Emit.EagerBody(equation) #>;
<#      } #>
    }
<#      foreach (var group in node.DeclaredInheritedAttributeEquationGroups) { #>

    internal override <#= Emit.Type(group.Type) #> Inherited<#= group.Name #>(<#= Emit.BaseClassName(tree) #> child, <#= Emit.BaseClassName(tree) #> descendant, IInheritanceContext ctx)
    {
<#          foreach (var eq in group.Equations) { #>
        <#= Emit.Selector(eq) #>return <#= Emit.Body(eq) #>;
<#          } #>
<#          if (group.Equations.All(i => !i.IsAllDescendants)) { #>
        return base.Inherited<#= group.Name #>(child, descendant, ctx);
<#          } #>
    }
<#      } #>
}

<#  } #>
<#  } #>