<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Attributes" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Equations" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Syntax.Equations" #>
<#  foreach(var usingNamespace in Build.OrderedNamespaces(tree, "ExhaustiveMatching", "System.CodeDom.Compiler", "System.Diagnostics")) { #>
using <#=usingNamespace #>;
<#  } #>

namespace <#=tree.Namespace #>;

// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable RedundantTypeDeclarationBody
// ReSharper disable ReturnTypeCanBeNotNullable
// ReSharper disable ConvertToPrimaryConstructor

<#  foreach(var node in tree.Nodes) {#>
<#=Emit.ClosedAttribute(node) #>[GeneratedCode("AzothCompilerCodeGen", null)]
public partial interface <#= Emit.TypeName(node.Defines) #><#= Emit.BaseTypes(node) #>
{
<#      foreach (var attribute in node.AttributesRequiringDeclaration) { #>
<#          switch (attribute) { #>
<#              case PropertyModel attr: #>
    <#=Emit.IsNew(attr) #><#=Emit.Type(attr.Type) #> <#=attr.Name #> { get; }
<#                  break;#>
<#              case SynthesizedAttributeModel attr: #>
    <#=Emit.Type(attr.Type) #> <#=attr.Name #><#=attr.Parameters #><#=Emit.Body(attr) #>
<#                  break;#>
<#          } #>
<#          foreach (var baseAttribute in Build.BaseAttributes(node, attribute)) { #>
    <#=Emit.Type(baseAttribute.Type) #> <#= Emit.TypeName(baseAttribute.Node.Defines) #>.<#=baseAttribute.Name #> => <#=attribute.Name #>;
<#          } #>
<#      } #>
<#      foreach (var equation in node.DeclaredEquations) { #>
<#          switch (equation) { #>
<#              case SynthesizedAttributeEquationModel eq when eq.Expression is not null: #>
    <#=Emit.Type(eq.Type) #> <#= Emit.TypeName(eq.Attribute.NodeSymbol) #>.<#=eq.Name #><#=eq.Parameters #><#=Emit.Body(eq) #>
<#                  break;#>
<#          } #>
<#      } #>
<#      if (tree.GenerateClasses && !node.IsAbstract) { #>

    public static <#= Emit.TypeName(node.Defines) #> Create(<#=string.Join(", ", node.ActualProperties.Select(p => $"{Emit.Type(p.Type)} {Emit.ParameterName(p)}")) #>)
        => new <#= Emit.ClassName(node.Defines) #>(<#=string.Join(", ", node.ActualProperties.Select(p => Emit.ParameterName(p))) #>);
<#      } #>
}

<#  } #>
<#  if (tree.GenerateClasses) { #>
<#  foreach(var node in tree.Nodes.Where(ShouldEmit.Class)) {#>
[GeneratedCode("AzothCompilerCodeGen", null)]
file sealed class <#= Emit.ClassName(node.Defines) #> : <#= Emit.TypeName(node.Defines) #>
{
<#      foreach (var property in node.ActualProperties) { #>
    public <#=Emit.Type(property.Type) #> <#=property.Name #> { [DebuggerStepThrough] get; }
<#      } #>
<#      foreach (var equation in node.ActualEquations) { #>
<#          switch (equation) { #>
<#              case SynthesizedAttributeEquationModel eq: #>
    public <#= Emit.Override(eq) #><#=Emit.Type(eq.Type) #> <#=eq.Name #><#=eq.Parameters #><#=Emit.Body(eq) #>
<#                  break;#>
<#          } #>
<#      } #>

    public <#= Emit.ClassName(node.Defines) #>(<#=string.Join(", ", node.ActualProperties.Select(p => $"{Emit.Type(p.Type)} {Emit.ParameterName(p)}")) #>)
    {
<#      foreach (var property in node.ActualProperties) { #>
        <#=property.Name #> = <#=Emit.ParameterName(property) #>;
<#      } #>
    }
}

<#  } #>
<#  } #>