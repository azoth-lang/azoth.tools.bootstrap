<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#  foreach(var usingNamespace in Build.OrderedNamespaces(pass, "ExhaustiveMatching", "System.Linq", "System.Collections.Generic", "System.Diagnostics.CodeAnalysis", "System.CodeDom.Compiler", "Azoth.Tools.Bootstrap.Compiler.IST", "Azoth.Tools.Bootstrap.Framework")) { #>
using <#=usingNamespace #>;
<#  } #><#=Emit.UsingAlias("From", pass.FromLanguage)#><#=Emit.UsingAlias("To", pass.ToLanguage)#>
namespace <#=pass.Namespace #>;

[GeneratedCode("AzothCompilerCodeGen", null)]
internal sealed partial class <#=pass.Name #> : ITransformPass<<#=Emit.TransformInterfaceTypeParameters(pass)#>>
{
    public static <#=Emit.RunReturnType(pass)#> Run(<#=Emit.RunParameters(pass)#>)
    {
        var pass = new <#=pass.Name#>(<#=Emit.ContextParameterName(pass)#>);
        <#=Emit.StartRunResult(pass)#>pass.StartRun();
        <#=Emit.EntryResult(pass)#>pass.<#=Emit.OperationMethodName(pass.EntryTransform)#>(<#=Emit.EntryParameterNames(pass)#>);
        <#=Emit.EndRunResult(pass)#>pass.EndRun(<#=Emit.EndRunArguments(pass)#>);
        return <#=Emit.RunReturnNames(pass)#>;
    }

<#  if (ShouldEmit.RunExplicitImplementation(pass)) { #>
    static <#=Emit.FullRunReturnType(pass)#> ITransformPass<<#=Emit.TransformInterfaceTypeParameters(pass)#>>.Run(<#=Emit.FullRunParameters(pass)#>)
        => <#=Emit.RunForward(pass)#>;

<#  } #>

    <#=Emit.StartRunAccessModifier(pass)#>partial <#=Emit.StartRunReturnType(pass)#> StartRun();

    <#=Emit.EndRunAccessModifier(pass)#>partial <#=Emit.EndRunReturnType(pass)#> EndRun(<#=Emit.EndRunParameters(pass)#>);

<#  foreach (var transform in pass.TransformMethods.Where(t => !t.AutoGenerate)) { #>
    <#=Emit.AccessModifier(transform)#>partial <#=Emit.ReturnType(transform)#> <#=Emit.OperationMethodName(transform)#>(<#=Emit.Parameters(transform)#>);

<#  } #>
<#  foreach (var transform in pass.TransformMethods.Where(t => t.AutoGenerate)) { #>
    <#=Emit.TransformNotNullAttribute(transform)#>private <#=Emit.ReturnType(transform)#> <#=Emit.OperationMethodName(transform)#>(<#=Emit.Parameters(transform)#>)
        => <#=Emit.TransformMethodBody(transform)#>;

<#  } #>
<#  foreach (var transform in pass.Transforms.Where(t => t.AutoGenerate)) { #>
/*  <#=Emit.TransformNotNullAttribute(transform)#>private <#=Emit.ReturnType(transform)#> <#=Emit.OperationMethodName(transform)#>(<#=Emit.Parameters(transform)#>)
        => <#=Emit.TransformMethodBody(transform)#>; */

<#  } #>
<#  if (pass.SimpleCreateMethods.Any()) { #>
    #region Create() methods
<#      foreach (var method in pass.SimpleCreateMethods) { #>
    private <#=Emit.PassReturnType(pass, method.ReturnType)#> Create<#=Emit.TypeName(method.To)#>(<#=Emit.Parameters(pass, method.AllParameters)#>)
        => <#=Emit.PassTypeName(pass, method.To)#>.Create(<#=Emit.SimpleCreateArguments(method)#>);

<#      } #>
    #endregion

<#  } #>
<#  if (pass.AdvancedCreateMethods.Any()) { #>
    #region CreateX() methods
<#      foreach (var method in pass.AdvancedCreateMethods) { #>
    private <#=Emit.PassReturnType(pass, method.ReturnType)#> Create<#=Emit.TypeName(method.To)#>(<#=Emit.Parameters(pass, method.AllParameters)#>)
        => <#=Emit.AdvancedCreateMethodBody(pass, method)#>;

<#      } #>
<#      foreach (var rule in Build.AdvancedCreateRules(pass)) { #>
/*  private <#=Emit.PassTypeName(pass, rule.Defines)#> Create<#=Emit.TypeName(rule.Defines)#>(<#=Emit.AdvancedCreateParameters(pass, rule)#>)
        => <#=Emit.AdvancedCreateMethodBody(pass, rule)#>; */

<#      } #>
    #endregion
<#  } #>
}
