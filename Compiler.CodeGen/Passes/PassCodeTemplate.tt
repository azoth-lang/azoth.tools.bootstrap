<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#  foreach(var usingNamespace in Build.OrderedNamespaces(pass, "ExhaustiveMatching", "System.Linq", "System.Collections.Generic", "System.Diagnostics.CodeAnalysis", "System.CodeDom.Compiler", "Azoth.Tools.Bootstrap.Compiler.IST", "Azoth.Tools.Bootstrap.Framework")) { #>
using <#=usingNamespace #>;
<#  } #><#=Emit.UsingAlias("From", pass.FromLanguage)#><#=Emit.UsingAlias("To", pass.ToLanguage)#>
namespace <#=pass.Namespace #>;

[GeneratedCode("AzothCompilerCodeGen", null)]
internal sealed partial class <#=pass.Name #> : ITransformPass<<#=Emit.TransformInterfaceTypeParameters(pass)#>>
{
    public static <#=Emit.RunReturnType(pass)#> Run(<#=Emit.RunParameters(pass)#>)
    {
        var pass = new <#=pass.Name#>(<#=Emit.ContextParameterName(pass)#>);
        <#=Emit.StartRunResult(pass)#>pass.StartRun();
        <#=Emit.EntryResult(pass)#>pass.<#=Emit.MethodName(pass)#>(<#=Emit.EntryParameterNames(pass)#>);
        <#=Emit.EndRunResult(pass)#>pass.EndRun(<#=Emit.EndRunArguments(pass)#>);
        return <#=Emit.RunReturnNames(pass)#>;
    }

<#  if (ShouldEmit.RunExplicitImplementation(pass)) { #>
    static <#=Emit.FullRunReturnType(pass)#> ITransformPass<<#=Emit.TransformInterfaceTypeParameters(pass)#>>.Run(<#=Emit.FullRunParameters(pass)#>)
        => <#=Emit.RunForward(pass)#>;

<#  } #>

    <#=Emit.StartRunAccessModifier(pass)#>partial <#=Emit.StartRunReturnType(pass)#> StartRun();

    <#=Emit.EndRunAccessModifier(pass)#>partial <#=Emit.EndRunReturnType(pass)#> EndRun(<#=Emit.EndRunParameters(pass)#>);

<#  foreach (var transform in pass.Transforms.Where(t => !t.AutoGenerate)) { #>
    <#=Emit.AccessModifier(transform)#>partial <#=Emit.ReturnType(transform)#> <#=Emit.MethodName(pass)#>(<#=Emit.Parameters(transform)#>);

<#  } #>
<#  foreach (var transform in pass.Transforms.Where(t => t.AutoGenerate)) { #>
    <#=Emit.TransformNotNullAttribute(transform)#>private <#=Emit.ReturnType(transform)#> <#=Emit.MethodName(pass)#>(<#=Emit.Parameters(transform)#>)
        => <#=Emit.TransformMethodBody(transform)#>;

<#  } #>
<#  foreach (var rule in Build.SimpleCreateRules(pass)) { #>
    private <#=Emit.PassTypeName(pass, rule.Defines)#> Create(<#=Emit.DifferentParameters(pass, rule)#>)
        => <#=Emit.PassTypeName(pass, rule.Defines)#>.Create(<#=Emit.SimpleCreateParameters(rule)#>);

<#  } #>
}
