using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Types;
using Azoth.Tools.Bootstrap.Framework;

namespace Azoth.Tools.Bootstrap.Compiler.CodeGen.Model.Methods;

/// <summary>
/// A declared transform method that can just return the input value as is.
/// </summary>
public sealed record TransformIdentityMethod : TransformMethod
{
    public override required IFixedList<Parameter> AdditionalParameters { get; init; }

    public override NonVoidType ToType { get; }
    public override Parameter To { get; }
    public IFixedList<Parameter> AdditionalReturnValues { get; }
    public override IFixedList<Parameter> AllReturnValues { get; }
    public override bool AutoGenerate => true;

    [SetsRequiredMembers]
    public TransformIdentityMethod(Pass pass, Transform transform, NonVoidType fromType, NonVoidType toType)
        : this(pass, parametersDeclared: true, fromType, transform.AdditionalParameters, toType, transform.AdditionalReturnValues)
    {
        Requires.That(nameof(transform), transform.AutoGenerate, "Must be autogenerated");
    }

    [SetsRequiredMembers]
    public TransformIdentityMethod(Pass pass, NonVoidType fromType, NonVoidType toType)
        : this(pass, parametersDeclared: false, fromType, FixedList.Empty<Parameter>(), toType, FixedList.Empty<Parameter>())
    {
    }

    [SetsRequiredMembers]
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    private TransformIdentityMethod(Pass pass,
        bool parametersDeclared,
        NonVoidType fromType, IFixedList<Parameter> additionalParameters,
        NonVoidType toType, IFixedList<Parameter> additionalReturnValues)
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        : base(pass, parametersDeclared, fromType)
    {
        AdditionalParameters = additionalParameters;

        ToType = toType;
        To = Parameter.Create(toType, Parameter.ToName);
        AdditionalReturnValues = additionalReturnValues;
        AllReturnValues = AdditionalReturnValues.Prepend(To).ToFixedList();
    }

    public override IEnumerable<Method> GetMethodsCalled() => Enumerable.Empty<Method>();

    public override TransformIdentityMethod ToOptional()
    {
        if (ParametersDeclared)
            throw new NotSupportedException("Cannot make a method with declared parameters optional.");
        return new(Pass, ParametersDeclared,
            new OptionalType(FromType), AdditionalParameters,
            new OptionalType(ToType), AdditionalReturnValues);
    }
}
