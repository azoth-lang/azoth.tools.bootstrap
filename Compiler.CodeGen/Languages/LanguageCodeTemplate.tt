<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#  foreach(var usingNamespace in grammar.OrderedUsingNamespaces("ExhaustiveMatching", "System.CodeDom.Compiler", grammar.Namespace + ".Classes")) { #>
using <#=usingNamespace #>;
<#  } #>

namespace <#=grammar.Namespace #>;

// ReSharper disable InconsistentNaming
// ReSharper disable PartialTypeWithSinglePart

[GeneratedCode("AzothCompilerCodeGen", null)]
public sealed class <#=language.Name #>
{
<#  foreach(var rule in grammar.Rules) {#>
<#=Emit.ClosedAttribute(grammar, rule, indent: "    ") #>    public interface <#= grammar.TypeName(rule.Defines) #><#= Emit.BaseTypes(grammar, rule, "IImplementationRestricted") #>
    {
<#      foreach(var property in rule.Properties.Where(p => ShouldEmit.Property(grammar, rule, p))) { #>
        <#=Emit.PropertyIsNew(grammar, rule, property) #><#=Emit.Type(grammar, property.Type) #> <#=property.Name #> { get; }
<#      } #>
<#      if (grammar.IsLeaf(rule)) { #>

        public static <#= grammar.TypeName(rule.Defines) #> Create(<#=Emit.PropertyParameters(grammar, rule) #>)
           => new <#=Emit.SmartClassName(language, rule.Defines) #>(<#=Emit.PropertyArguments(language, rule) #>);
<#          if (language.IsModified(rule)) { #>

        public static <#= grammar.TypeName(rule.Defines) #> Create(<#=Emit.ModifiedPropertyParameters(language, rule) #>)
           => new <#=Emit.SmartClassName(language, rule.Defines) #>(<#=Emit.ModifiedPropertyArguments(language, rule) #>);
<#          } #>
<#      } #>
    }

<#  } #>
}
