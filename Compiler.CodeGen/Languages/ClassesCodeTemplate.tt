<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Azoth.Tools.Bootstrap.Compiler.CodeGen.Core" #>
<#  foreach(var usingNamespace in grammar.OrderedUsingNamespaces("System.CodeDom.Compiler")) { #>
using <#=usingNamespace #>;
<#  } #>

// ReSharper disable InconsistentNaming
// ReSharper disable PartialTypeWithSinglePart

// ReSharper disable once CheckNamespace
namespace <#=grammar.Namespace #>;

<#  foreach(var rule in language.DifferentRules.Where(ShouldEmit.Class)) {#>
[GeneratedCode("AzothCompilerCodeGen", null)]
internal <#=Emit.ClassModifier(language, rule) #> partial class <#=Emit.ClassName(language, rule.Defines) #> : <#=Emit.ClassName(language, rule.Parent) #>, <#=Emit.QualifiedTypeName(language, rule.Defines) #>
{
<#      foreach(var property in grammar.AllProperties(rule)) { #>
    public <#=Emit.ClassPropertyModifier(language, rule) #> <#=Emit.ClassType(language, property.Type) #> <#=property.Name #> { get; }
<#          if (grammar.IsNonterminal(property)) { #>
    <#=Emit.QualifiedType(language, property.Type) #> <#= Emit.QualifiedTypeName(language, rule.Defines) #>.<#=property.Name #> => <#=property.Name #>;
<#          } #>
<#      } #>

<#      if (ShouldEmit.Constructor(language, rule)) { #>
    public <#=Emit.ClassName(language, rule.Defines) #>(<#=Emit.PropertyClassParameters(language, rule) #>)
    {
<#          foreach(var property in grammar.AllProperties(rule)) { #>
        <#=property.Name #> = <#=property.Name.ToCamelCase() #>;
<#          } #>
    }
<#      } #>
 }

<#  } #>

<#   foreach(var (otherLanguage, rules) in OtherLanguagesDefiningRules()) {#>
namespace <#=otherLanguage.Grammar.Namespace #>.Classes
{
    using static <#=grammar.Namespace #>.<#=language.Name #>;

<#      foreach(var rule in rules.Where(r => grammar.IsTerminal(r))) {#>
    internal sealed partial class <#=Emit.ClassName(otherLanguage, rule.Defines) #> : <#= grammar.TypeName(rule.Defines) #>
    {
<#      foreach(var property in grammar.AllProperties(rule)) { #>
<#          if (grammar.IsNonterminal(property)) { #>
        <#=Emit.Type(language, property.Type) #> <#= Emit.TypeName(language, rule.Defines) #>.<#=property.Name #> => <#=property.Name #>;
<#          } #>
<#      } #>
    }
<#      } #>
}
<#  } #>