◊name Concrete;
◊namespace Azoth.Tools.Bootstrap.Compiler.IST;
◊entry Package;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Framework;

Package = Syntax:`IPackageSyntax` Symbol:`PackageSymbol` References:{PackageReference}
    CompilationUnits:{CompilationUnit} TestingCompilationUnits:{CompilationUnit};

PackageReference = Syntax:`IPackageReferenceSyntax`
    AliasOrName:`IdentifierName` Package:`IPackageSymbols` IsTrusted:`bool`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax` File:`CodeFile` ImplicitNamespaceName:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

Code = Syntax:`IConcreteSyntax`;

// ---------- Declarations
Declaration: Code = Syntax:`IDeclarationSyntax`;
NamespaceMemberDeclaration: Declaration;
NamespaceDeclaration <: NamespaceMemberDeclaration = Syntax:`INamespaceDeclarationSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*;

// ---------- Type Declarations
TypeDeclaration <: NamespaceMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`ITypeDeclarationSyntax` GenericParameters:GenericParameter* SupertypeNames:UnresolvedSupertypeName*;
ClassDeclaration: TypeDeclaration = Syntax:`IClassDeclarationSyntax` IsAbstract:`bool` BaseTypeName:UnresolvedSupertypeName? Members:ClassMemberDeclaration*;
StructDeclaration: TypeDeclaration = Syntax:`IStructDeclarationSyntax` Members:StructMemberDeclaration*;
TraitDeclaration: TypeDeclaration = Syntax:`ITraitDeclarationSyntax` Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameter: Code = Syntax:`IGenericParameterSyntax` Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`;
UnresolvedSupertypeName: Code = Syntax:`ISupertypeNameSyntax` Name:`TypeName` TypeArguments:UnresolvedType*;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration: Declaration = Syntax:`ITypeMemberDeclarationSyntax`;
ClassMemberDeclaration: TypeMemberDeclaration = Syntax:`IClassMemberDeclarationSyntax`;
TraitMemberDeclaration: TypeMemberDeclaration = Syntax:`ITraitMemberDeclarationSyntax`;
StructMemberDeclaration: TypeMemberDeclaration = Syntax:`IStructMemberDeclarationSyntax`;

// ---------- Invocable Declarations
FunctionDeclaration <: NamespaceMemberDeclaration = Syntax:`IFunctionDeclarationSyntax`;

// ---------- Capabilities
CapabilityConstraint: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`ICapabilityConstraint`;
CapabilitySet: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`Types.Capabilities.CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Types.Capabilities.Capability` Constraint:`Types.Capabilities.Capability`;

// ---------- Unresolved Types
UnresolvedType: Code = Syntax:`ITypeSyntax`;
UnresolvedTypeName: UnresolvedType = Syntax:`ITypeNameSyntax` Name:`TypeName`;
UnresolvedStandardTypeName: UnresolvedTypeName = Syntax:`IStandardTypeNameSyntax` Name:`StandardName`;
UnresolvedSimpleTypeName: UnresolvedTypeName = Syntax:`ISimpleTypeNameSyntax`;
UnresolvedIdentifierTypeName: UnresolvedTypeName <: UnresolvedStandardTypeName, UnresolvedSimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
UnresolvedSpecialTypeName: UnresolvedSimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`;
UnresolvedGenericTypeName: UnresolvedStandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:UnresolvedType*;
UnresolvedQualifiedTypeName: UnresolvedTypeName = Syntax:`IQualifiedTypeNameSyntax` Context:UnresolvedTypeName QualifiedName:UnresolvedStandardTypeName;
UnresolvedOptionalType: UnresolvedType = Syntax:`IOptionalTypeSyntax` Referent:UnresolvedType;
UnresolvedCapabilityType: UnresolvedType = Syntax:`ICapabilityTypeSyntax` Capability Referent:UnresolvedType;
UnresolvedFunctionType: UnresolvedType = Syntax:`IFunctionTypeSyntax` Parameters:UnresolvedParameterType* Return:UnresolvedType;
UnresolvedParameterType = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:UnresolvedType;
UnresolvedViewpointType: UnresolvedType = Syntax:`IViewpointTypeSyntax` Referent:UnresolvedType;
UnresolvedCapabilityViewpointType: UnresolvedViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability;
UnresolvedSelfViewpointType: UnresolvedViewpointType = Syntax:`ISelfViewpointTypeSyntax`;
