using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
using Azoth.Tools.Bootstrap.Compiler.Syntax;

namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Tree;

internal abstract class ChildNode : SemanticNode, IChildNode
{
    public IPackageDeclarationNode Package => Inherited_Package(GrammarAttribute.CurrentInheritanceContext());

    public abstract ISyntax? Syntax { get; }

    // TODO this should only be available in the final tree
    ISemanticNode IChildNode.Parent => (ISemanticNode)PeekParent()!;

    //#region Generated by new SemanticNode
    //private bool inFinalTree;

    ///// <remarks>Volatile read not necessary because an out-of-order read is not an issue since it
    ///// will just re-figure out the fact that the node is final.</remarks>
    //protected sealed override bool InFinalTree => inFinalTree;

    //private SemanticNode? parent;

    //protected SemanticNode Parent
    //{
    //    [DebuggerStepThrough]
    //    // Use volatile read to ensure order of operations as seen by other threads
    //    get => Volatile.Read(in parent) ?? throw Child.ParentMissing(this);
    //}

    //[DebuggerStepThrough]
    //protected sealed override SemanticNode PeekParent()
    //    // Use volatile read to ensure order of operations as seen by other threads
    //    => Volatile.Read(in parent) ?? throw Child.ParentMissing(this);

    //protected SemanticNode GetParent(IInheritanceContext ctx)
    //{
    //    // Use volatile read to ensure order of operations as seen by other threads
    //    var node = Volatile.Read(in parent) ?? throw Child.ParentMissing(this);
    //    ctx.AccessParentOf(this);
    //    return node;
    //}

    //private protected ChildNode()
    //{
    //}

    //void IChildTreeNode<ISemanticNode>.SetParent(ISemanticNode newParent)
    //{
    //    if (newParent is not SemanticNode newParentNode)
    //        throw new ArgumentException($"Parent must be a {nameof(SemanticNode)}.", nameof(newParent));

    //    // Use volatile write to ensure order of operations as seen by other threads
    //    Volatile.Write(ref parent, newParentNode);
    //}

    ///// <remarks>Volatile write not necessary because an out-of-order read is not an issue since it
    ///// will just re-figure out the fact that the node is final. Does not check the invariant that
    ///// the parent is in the final tree because that would probably require a volatile read and that
    ///// volatile was used in other places too.</remarks>
    //protected sealed override void MarkInFinalTree()
    //    => inFinalTree = true;

    ///// <summary>
    ///// The previous node to this one in a preorder traversal of the tree.
    ///// </summary>
    //protected virtual SemanticNode Previous(IInheritanceContext ctx)
    //{
    //    SemanticNode? previous = null;
    //    var parent = GetParent(ctx);
    //    foreach (var child in parent.Children().Cast<SemanticNode>())
    //    {
    //        if (child == this)
    //            // If this is the first child, return the parent without descending
    //            return previous?.LastDescendant() ?? parent;
    //        previous = child;
    //    }

    //    throw new UnreachableException("Node is not a child of its parent.");
    //}

    //internal override ISymbolDeclarationNode Inherited_ContainingDeclaration(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingDeclaration(this, descendant, ctx);

    //protected ISymbolDeclarationNode Inherited_ContainingDeclaration(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingDeclaration(this, this, ctx);

    //internal override IPackageDeclarationNode Inherited_Package(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_Package(this, descendant, ctx);

    //protected IPackageDeclarationNode Inherited_Package(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_Package(this, this, ctx);

    //internal override CodeFile Inherited_File(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_File(this, descendant, ctx);

    //protected CodeFile Inherited_File(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_File(this, this, ctx);

    //internal override PackageNameScope Inherited_PackageNameScope(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_PackageNameScope(this, descendant, ctx);

    //protected PackageNameScope Inherited_PackageNameScope(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_PackageNameScope(this, this, ctx);

    //internal override LexicalScope Inherited_ContainingLexicalScope(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingLexicalScope(this, descendant, ctx);

    //protected LexicalScope Inherited_ContainingLexicalScope(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingLexicalScope(this, this, ctx);

    //internal override IDeclaredUserType Inherited_ContainingDeclaredType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingDeclaredType(this, descendant, ctx);

    //protected virtual IDeclaredUserType Inherited_ContainingDeclaredType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingDeclaredType(this, this, ctx);

    //internal override Pseudotype? Inherited_MethodSelfType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_MethodSelfType(this, descendant, ctx);

    //protected Pseudotype? Inherited_MethodSelfType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_MethodSelfType(this, this, ctx);

    //internal override ITypeDefinitionNode Inherited_ContainingTypeDefinition(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingTypeDefinition(this, descendant, ctx);

    //protected ITypeDefinitionNode Inherited_ContainingTypeDefinition(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContainingTypeDefinition(this, this, ctx);

    //internal override bool Inherited_IsAttributeType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_IsAttributeType(this, descendant, ctx);

    //protected bool Inherited_IsAttributeType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_IsAttributeType(this, this, ctx);

    //internal override IPackageFacetDeclarationNode Inherited_Facet(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_Facet(this, descendant, ctx);

    //protected IPackageFacetDeclarationNode Inherited_Facet(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_Facet(this, this, ctx);

    //internal override ISymbolTree Inherited_SymbolTree(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_SymbolTree(this, descendant, ctx);

    //protected ISymbolTree Inherited_SymbolTree(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_SymbolTree(this, this, ctx);

    //internal override IFlowState Inherited_FlowStateBefore(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_FlowStateBefore(this, descendant, ctx);

    //protected IFlowState Inherited_FlowStateBefore(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_FlowStateBefore(this, this, ctx);

    //internal override IMaybeAntetype Inherited_ContextBindingAntetype(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContextBindingAntetype(this, descendant, ctx);

    //protected IMaybeAntetype Inherited_ContextBindingAntetype(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContextBindingAntetype(this, this, ctx);

    //internal override DataType Inherited_ContextBindingType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContextBindingType(this, descendant, ctx);

    //protected DataType Inherited_ContextBindingType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ContextBindingType(this, this, ctx);

    //internal override ValueId? Inherited_MatchReferentValueId(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_MatchReferentValueId(this, descendant, ctx);

    //protected ValueId? Inherited_MatchReferentValueId(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_MatchReferentValueId(this, this, ctx);

    //internal override IMaybeExpressionAntetype? Inherited_ExpectedAntetype(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedAntetype(this, descendant, ctx);

    //protected IMaybeExpressionAntetype? Inherited_ExpectedAntetype(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedAntetype(this, this, ctx);

    //internal override DataType? Inherited_ExpectedType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedType(this, descendant, ctx);

    //protected DataType? Inherited_ExpectedType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedType(this, this, ctx);

    //internal override DataType? Inherited_ExpectedReturnType(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedReturnType(this, descendant, ctx);

    //protected DataType? Inherited_ExpectedReturnType(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ExpectedReturnType(this, this, ctx);

    //internal override ControlFlowSet Inherited_ControlFlowFollowing(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowFollowing(this, descendant, ctx);

    //protected ControlFlowSet Inherited_ControlFlowFollowing(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowFollowing(this, this, ctx);

    //internal override FixedDictionary<IVariableBindingNode, int> Inherited_VariableBindingsMap(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_VariableBindingsMap(this, descendant, ctx);

    //protected FixedDictionary<IVariableBindingNode, int> Inherited_VariableBindingsMap(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_VariableBindingsMap(this, this, ctx);

    //internal override IEntryNode Inherited_ControlFlowEntry(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowEntry(this, descendant, ctx);

    //protected IEntryNode Inherited_ControlFlowEntry(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowEntry(this, this, ctx);

    //internal override IExitNode Inherited_ControlFlowExit(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowExit(this, descendant, ctx);

    //protected IExitNode Inherited_ControlFlowExit(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ControlFlowExit(this, this, ctx);

    //internal override bool Inherited_ImplicitRecoveryAllowed(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ImplicitRecoveryAllowed(this, descendant, ctx);

    //protected bool Inherited_ImplicitRecoveryAllowed(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ImplicitRecoveryAllowed(this, this, ctx);

    //internal override bool Inherited_ShouldPrepareToReturn(SemanticNode child, SemanticNode descendant, IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ShouldPrepareToReturn(this, descendant, ctx);

    //protected bool Inherited_ShouldPrepareToReturn(IInheritanceContext ctx)
    //    => GetParent(ctx).Inherited_ShouldPrepareToReturn(this, this, ctx);

    //internal override IPreviousValueId Previous_PreviousValueId(SemanticNode before, IInheritanceContext ctx)
    //    => Previous(ctx).Previous_PreviousValueId(before, ctx);

    //protected IPreviousValueId Previous_PreviousValueId(IInheritanceContext ctx)
    //    => Previous(ctx).Previous_PreviousValueId(this, ctx);
    //#endregion


}
