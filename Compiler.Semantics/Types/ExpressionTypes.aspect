◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Types;
◊name ExpressionTypesAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Diagnostics;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Types.Flow;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;

// ↓ ⟳ ↑ ⮡ ↗↖ →*← ✎

// ---------- Function Parts
↓ ExpressionBody.ExpectedType: `DataType`?;
= ExpressionBody.ResultStatement.ExpectedType => ExpectedType;
// Really, only the expression immediately inside the result statement should inherit true. But
// there is no way to select that. Instead broadcast, and rely on other expressions to override.
= ExpressionBody.ResultStatement.**.ImplicitRecoveryAllowed() => true;
// Really, only the expression immediately inside the result statement should inherit true. But
// there is no way to select that. Instead broadcast, and rely on other expressions to override.
= ExpressionBody.ResultStatement.**.ShouldPrepareToReturn() => true;

// ---------- Parameters
↓ Parameter.FlowStateBefore(): `IFlowState`;
⟳ Parameter.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
= SelfParameter.FlowStateAfter;
↑ FieldParameter.FlowStateAfter: `IFlowState` => FlowStateBefore();

// ---------- Statements
↑ Statement.ResultType: `DataType`? => null;
⟳ Statement.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
↓ ResultStatement.ExpectedType: `DataType`?;
= ResultStatement.Expression.ExpectedType => ExpectedType;
= ResultStatement.Type;
= ResultStatement.ResultType => Type;
↑ ResultStatement.FlowStateAfter: `IFlowState`
    => Expression?.FlowStateAfter ?? IFlowState.Empty;
↓ VariableDeclarationStatement.FlowStateBefore(): `IFlowState`;
// The expected type for the initializer is the binding type since it needs to have any
// Capability declared on the variable applied.
= VariableDeclarationStatement.Initializer.ExpectedType => BindingType;
= VariableDeclarationStatement.Initializer.ImplicitRecoveryAllowed() => true;
= VariableDeclarationStatement.Initializer.ShouldPrepareToReturn() => false;
= ExpressionStatement.Expression.ExpectedType => null;
= ExpressionStatement.Expression.ImplicitRecoveryAllowed() => false;
= ExpressionStatement.Expression.ShouldPrepareToReturn() => false;

// ---------- Patterns
⟳ Pattern.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
↑ BindingContextPattern.FlowStateAfter: `IFlowState` => Pattern.FlowStateAfter;
↓ BindingPattern.FlowStateBefore(): `IFlowState`;
↑ OptionalPattern.FlowStateAfter: `IFlowState` => Pattern.FlowStateAfter;

// ---------- Expressions
// By default, implicit recovery is not allowed
= AmbiguousExpression.*.**.ImplicitRecoveryAllowed() => false;
// By default, don't need to prepare to return
= AmbiguousExpression.*.**.ShouldPrepareToReturn() => false;
// TODO remove once all nodes properly provide the expected type
= AmbiguousExpression.*.ExpectedType => null;
↓ Expression.ExpectedType:`DataType`?;
/// <summary>
/// Whether an implicit recovery (i.e. move or freeze) is allowed to convert this expression to
/// the expected type.
/// </summary>
↓ Expression.ImplicitRecoveryAllowed(): `bool`;
/// <summary>
/// Whether this expression should be prepared for return.
/// </summary>
↓ Expression.ShouldPrepareToReturn(): `bool`;
↑ Expression.Type: `DataType`;
⟳ Expression.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
= Expression.↑.Diagnostics;
✎ Expression ImplicitMove;
✎ Expression ImplicitFreeze;
✎ Expression PrepareToReturn;

↓ BlockExpression.FlowStateBefore(): `IFlowState`;
// TODO it would be better to have a way to specify that this inherits and not emit any code
= BlockExpression.Statements[0].**.FlowStateBefore()
    => base.Inherited_FlowStateBefore(child, descendant, ctx);
= BlockExpression.Statements[index].**.FlowStateBefore() => Statements[index - 1].FlowStateAfter;
↑ BlockExpression.Type: `DataType`;
⟳ BlockExpression.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
↓ NewObjectExpression.FlowStateBefore(): `IFlowState`;
// TODO it would be better to have a way to specify that this inherits and not emit any code
= NewObjectExpression.Arguments[0].**.FlowStateBefore()
    => base.Inherited_FlowStateBefore(child, descendant, ctx);
= NewObjectExpression.Arguments[index].**.FlowStateBefore()
    => Arguments[index - 1]?.FlowStateAfter ?? IFlowState.Empty;
= NewObjectExpression.Arguments[index].ExpectedType
    => ContextualizedOverload?.ParameterTypes[index].Type;
↑ NewObjectExpression.ContextualizedOverload:`ContextualizedOverload`?;
= NewObjectExpression.↑.Diagnostics;

↑ NeverTypedExpression.Type: `NeverType` => DataType.Never;

// ---------- Literal Expressions
↓ LiteralExpression.FlowStateBefore(): `IFlowState`;
= LiteralExpression.FlowStateAfter;
↑ BoolLiteralExpression.Type: `BoolConstValueType`;
↑ IntegerLiteralExpression.Type: `IntegerConstValueType`;
↑ NoneLiteralExpression.Type:`OptionalType`;
= StringLiteralExpression.↑.Diagnostics;

// ---------- Operator Expressions
= AssignmentExpression.RightOperand.**.FlowStateBefore
    => LeftOperand?.FlowStateAfter ?? IFlowState.Empty;
= AssignmentExpression.RightOperand.ExpectedType => LeftOperand?.Type;
= AssignmentExpression.↑.Diagnostics;
= BinaryOperatorExpression.RightOperand.**.FlowStateBefore
    => LeftOperand?.FlowStateAfter ?? IFlowState.Empty;
= BinaryOperatorExpression.↑.Diagnostics;
= IdExpression.↑.Diagnostics;
= ConversionExpression.↑.Diagnostics;
= PatternMatchExpression.Type => DataType.Bool;

// ---------- Control Flow Expressions
⟳ IfExpression.FlowStateAfter: `IFlowState` initial => IFlowState.Empty;
= IfExpression.↑.Diagnostics;
= ReturnExpression.↑.Diagnostics;

// ---------- Invocation Expressions
= UnresolvedInvocationExpression.Expression.ExpectedType => null;
↓ FunctionInvocationExpression.FlowStateBefore(): `IFlowState`;
↑ FunctionInvocationExpression.ContextualizedOverload: `ContextualizedOverload`?;
= FunctionInvocationExpression.↑.Diagnostics;
↑ MethodInvocationExpression.ContextualizedOverload: `ContextualizedOverload`?;
= MethodInvocationExpression.↑.Diagnostics;
↑ GetterInvocationExpression.ContextualizedOverload: `ContextualizedOverload`?;
= GetterInvocationExpression.FlowStateAfter;
= GetterInvocationExpression.↑.Diagnostics;
↑ SetterInvocationExpression.ContextualizedOverload: `ContextualizedOverload`?;
= SetterInvocationExpression.↑.Diagnostics;
↑ FunctionReferenceInvocationExpression.FunctionType: `FunctionType`;
= FunctionReferenceInvocationExpression.↑.Diagnostics;
↓ InitializerInvocationExpression.FlowStateBefore(): `IFlowState`;
↑ InitializerInvocationExpression.ContextualizedOverload: `ContextualizedOverload`?;
= UnknownInvocationExpression.Type => DataType.Unknown;
↑ UnknownInvocationExpression.FlowStateAfter: `IFlowState` => throw new NotImplementedException();

// ---------- Name Expressions
// TODO delete once all name expressions implement FlowStateAfter
↑ NameExpression.FlowStateAfter: `IFlowState`
    => throw new NotImplementedException($"{GetType().GetFriendlyName()}.{nameof(FlowStateAfter)} not implemented.");
↑ NamespaceName.Type: `UnknownType` => DataType.Unknown;
= FunctionGroupName.Type => throw new NotImplementedException();
↓ FunctionName.FlowStateBefore(): `IFlowState`;
= FunctionName.FlowStateAfter;
= FunctionName.*.**.ExpectedType => null;
= MethodGroupName.Type => throw new NotImplementedException();
= MethodGroupName.FlowStateAfter => Context.FlowStateAfter;
= FieldAccessExpression.FlowStateAfter;
= FieldAccessExpression.↑.Diagnostics;
= VariableNameExpression.FlowStateAfter;
↓ VariableNameExpression.FlowStateBefore(): `IFlowState`;
= TypeNameExpression.Type => DataType.Unknown;
= InitializerGroupName.Type => throw new NotImplementedException();
↑ SpecialTypeNameExpression.Type:`UnknownType` => DataType.Unknown;
↓ SelfExpression.FlowStateBefore(): `IFlowState`;
↑ SelfExpression.Pseudotype: `Pseudotype`;
= SelfExpression.FlowStateAfter;
↑ MissingNameExpression.Type: `UnknownType` => DataType.Unknown;
↑ UnknownNameExpression.Type: `UnknownType` => DataType.Unknown;
= UnknownMemberAccessExpression.FlowStateAfter;

// ---------- Capability Expressions
= MoveExpression.Type;
= MoveVariableExpression.↑.Diagnostics;
= MoveValueExpression.↑.Diagnostics;
= FreezeExpression.Type;
= FreezeVariableExpression.↑.Diagnostics;
= FreezeValueExpression.↑.Diagnostics;
= PrepareToReturnExpression.Type => Value.Type;

// ---------- Async Expressions
= AsyncBlockExpression.Type => Block.Type;
↑ AsyncBlockExpression.FlowStateAfter: `IFlowState` => throw new NotImplementedException();
