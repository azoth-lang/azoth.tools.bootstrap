◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Types;
◊name DefinitionTypesAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;

// ↓ ⟳ ↑ ⮡ ↗↖ →*← ✎

// ---------- Special Parts
↑ ElseClause.FlowStateAfter: `IFlowState`;
↑ BlockOrResult.Type: `DataType`;

// ---------- Definitions
↑ ConcreteFunctionInvocableDefinition.Type: `FunctionType`;

// ---------- Function Definition
= FunctionDefinition.Parameters[0].**.FlowStateBefore()
    => Self.FlowStateBefore();
= FunctionDefinition.Parameters[index].**.FlowStateBefore()
    => Parameters[index - 1].FlowStateAfter;
= FunctionDefinition.Body.**.FlowStateBefore()
    => Parameters.LastOrDefault()?.FlowStateAfter ?? Self.FlowStateBefore();
= FunctionDefinition.Body.ExpectedType => Type.Return.Type;
= FunctionDefinition.Body.**.ExpectedReturnType => Type.Return.Type;

// ---------- Type Definitions
= TypeDefinition.*.**.ContainingDeclaredType;

// ---------- Type Definition Parts
↓ GenericParameter.ContainingDeclaredType: `IDeclaredUserType`;

// ---------- Member Definitions
↓ AbstractMethodDefinition.ContainingDeclaredType: `IDeclaredUserType`;

// ---------- Parameters
↓ SelfParameter.ContainingDeclaredType: `IDeclaredUserType`;

// ---------- Function Parts
↑ Body.FlowStateAfter: `IFlowState`;
// TODO it would be better to have a way to specify that this inherits and not emit and code
= BlockBody.Statements[0].**.FlowStateBefore() => base.Inherited_FlowStateBefore(child, descendant, ctx);
= BlockBody.Statements[index].**.FlowStateBefore() => Statements[index - 1].FlowStateAfter;
= BlockBody.FlowStateAfter => throw new NotImplementedException();
= ExpressionBody.FlowStateAfter => throw new NotImplementedException();
