◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.PlainTypes;
◊name OverloadResolutionAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Diagnostics;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Plain;
◊using Azoth.Tools.Bootstrap.Framework;

// ↓ ⟳ ↑ ⮡ ↗↖ →*← ✎

// ---------- Expressions
↑ NewObjectExpression.CompatibleConstructors: {ConstructorDeclaration};
↑ NewObjectExpression.ReferencedConstructor: ConstructorDeclaration?;
= NewObjectExpression.↑.Diagnostics;

// ---------- Invocation Expressions
= UnresolvedInvocationExpression.Expression.ExpectedPlainType;
✎ UnresolvedInvocationExpression FunctionNameExpression;
✎ UnresolvedInvocationExpression MethodNameExpression;
✎ UnresolvedInvocationExpression TypeNameExpression;
✎ UnresolvedInvocationExpression InitializerGroupNameExpression;
✎ UnresolvedInvocationExpression FunctionReferenceExpression;
✎ UnresolvedInvocationExpression Unbound;
= UnresolvedInvocationExpression.↑.Diagnostics;

↑ FunctionInvocationExpression.SelectedCallCandidate: `ICallCandidate<IFunctionInvocableDeclarationNode>`?
    => Function.SelectedCallCandidate;

↑ MethodInvocationExpression.SelectedCallCandidate: `ICallCandidate<IOrdinaryMethodDeclarationNode>`?
    => Method.SelectedCallCandidate;
= MethodInvocationExpression.↑.Diagnostics;

↑ GetterInvocationExpression.CallCandidates: {`ICallCandidate<IPropertyAccessorDeclarationNode>`};
↑ GetterInvocationExpression.CompatibleCallCandidates: {`ICallCandidate<IGetterMethodDeclarationNode>`};
↑ GetterInvocationExpression.SelectedCallCandidate: `ICallCandidate<IGetterMethodDeclarationNode>`?
    => CompatibleCallCandidates.TrySingle();
↑ GetterInvocationExpression.ReferencedDeclaration: GetterMethodDeclaration?;

↑ eager SetterInvocationExpression.CallCandidates: {`ICallCandidate<IPropertyAccessorDeclarationNode>`};
↑ eager SetterInvocationExpression.CompatibleCallCandidates: {`ICallCandidate<ISetterMethodDeclarationNode>`};
// TODO eager doesn't support inline/default implementation yet.
↑ eager SetterInvocationExpression.SelectedCallCandidate: `ICallCandidate<ISetterMethodDeclarationNode>`?;
↑ eager SetterInvocationExpression.ReferencedDeclaration: SetterMethodDeclaration?;

↑ InitializerInvocationExpression.CompatibleDeclarations: {InitializerDeclaration};
↑ InitializerInvocationExpression.ReferencedDeclaration: InitializerDeclaration?;

// ---------- Name Expressions
↑ FunctionGroupName.CallCandidates: {`ICallCandidate<IFunctionInvocableDeclarationNode>`};
↑ FunctionGroupName.CompatibleCallCandidates: {`ICallCandidate<IFunctionInvocableDeclarationNode>`};
↑ FunctionGroupName.SelectedCallCandidate: `ICallCandidate<IFunctionInvocableDeclarationNode>`?;
↑ FunctionGroupName.ReferencedDeclaration: FunctionInvocableDeclaration?;
= FunctionGroupName.↑.Diagnostics;
= FunctionName.↑.Diagnostics;
↑ MethodGroupName.CallCandidates: {`ICallCandidate<IOrdinaryMethodDeclarationNode>`};
↑ MethodGroupName.CompatibleCallCandidates: {`ICallCandidate<IOrdinaryMethodDeclarationNode>`};
↑ MethodGroupName.SelectedCallCandidate: `ICallCandidate<IOrdinaryMethodDeclarationNode>`?;
↑ MethodGroupName.ReferencedDeclaration: OrdinaryMethodDeclaration?;
= MethodGroupName.↑.Diagnostics;
