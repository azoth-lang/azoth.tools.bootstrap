◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.PlainTypes;
◊name DefinitionPlainTypesAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Constructors;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Plain;

// ↓ ⟳ ↑ ⮡ ↗↖ →*← ✎

// ---------- Definitions
// TODO it would be good to refactor to not depend on Type
= ConcreteFunctionInvocableDefinition.ReturnPlainType => (Return?.NamedType ?? IType.Void).ToPlainType();
= ConcreteFunctionInvocableDefinition.PlainType;

// ---------- Function Definition
= FunctionDefinition.Body.ExpectedPlainType => Self.ReturnPlainType;
= FunctionDefinition.Body.**.ExpectedReturnPlainType => Self.ReturnPlainType;

// ---------- Type Definitions
↑ TypeDefinition.TypeConstructor:`OrdinaryTypeConstructor`;
= TypeDefinition.TypeConstructor;
↑ TypeDefinition.SelfPlainType: `SelfPlainType`;
= TypeDefinition.SelfPlainType;

// ---------- Member Definitions
= MethodDefinition.SelfParameterPlainType => SelfParameter.BindingPlainType;
= MethodDefinition.Body.**.ExpectedReturnPlainType => Self.ReturnPlainType;
= MethodDefinition.Body.ExpectedPlainType
    => Self.ReturnPlainType;

// TODO it would be good to refactor to not depend on Type
= MethodDefinition.ReturnPlainType => (Return?.NamedType ?? IType.Void).ToPlainType();
= FieldDefinition.BindingPlainType;
// TODO it would be good to refactor to not depend on Type
= AbstractMethodDefinition.MethodGroupPlainType => MethodGroupType.ToPlainType();
// TODO it would be good to refactor to not depend on Type
= StandardMethodDefinition.MethodGroupPlainType => MethodGroupType.ToPlainType();
= ConstructorDefinition.ReturnPlainType
    => ContainingTypeDefinition.TypeConstructor.ConstructWithGenericParameterPlainTypes();
= DefaultConstructorDefinition.SelfParameterPlainType
    => ContainingTypeDefinition.TypeConstructor.ConstructWithGenericParameterPlainTypes();
= SourceConstructorDefinition.SelfParameterPlainType => SelfParameter.BindingPlainType;
= SourceConstructorDefinition.Body.**.ExpectedReturnPlainType => IPlainType.Void;
= InitializerDefinition.ReturnPlainType
    => ContainingTypeDefinition.TypeConstructor.ConstructWithGenericParameterPlainTypes();
= DefaultInitializerDefinition.SelfParameterPlainType
    => ContainingTypeDefinition.TypeConstructor.ConstructWithGenericParameterPlainTypes();
= SourceInitializerDefinition.SelfParameterPlainType => SelfParameter.BindingPlainType;
= SourceInitializerDefinition.Body.**.ExpectedReturnPlainType => IPlainType.Void;
// Null is the signal that this is a field initializer and not a method body
= FieldDefinition.Initializer.**.ExpectedReturnPlainType => null;
= AssociatedFunctionDefinition.Body.ExpectedPlainType => Self.ReturnPlainType;
= AssociatedFunctionDefinition.Body.**.ExpectedReturnPlainType => Self.ReturnPlainType;
