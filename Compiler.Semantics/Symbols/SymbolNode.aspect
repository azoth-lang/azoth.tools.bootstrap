◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊name SymbolNodeAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Framework;

// ↓ ↑ ⮡ ✎

// ---------- Packages
↑ Package.PackageDeclarations: `FixedDictionary<IdentifierName, IPackageDeclarationNode>`;
↑ child PackageReference.SymbolNode: PackageSymbol;
= eager PackageReference.SymbolNode;
↑ PackageReference.PackageSymbols:`IPackageSymbols`;
= StandardPackageReference.PackageSymbols => Syntax.Package;
= IntrinsicsPackageReference.PackageSymbols => IntrinsicPackageSymbol.Instance;

// ---------- Facets
↑ PackageFacet.GlobalNamespace: NamespaceDefinition;

// ---------- Code Files
↑ CompilationUnit.ImplicitNamespace: NamespaceDefinition;

// ---------- Namespace Definitions
↑ NamespaceBlockDefinition.ContainingNamespace: NamespaceDefinition;
↑ NamespaceBlockDefinition.Definition: NamespaceDefinition;

// ---------- Function Definition
= FunctionDefinition.*.**.IsAttributeType => false;

// ---------- Type Definitions
= TypeDefinition.*.**.IsAttributeType => false;

// ---------- Attributes
= Attribute.TypeName.IsAttributeType => true;

// ---------- Parameters
↑ FieldParameter.ReferencedField: FieldDefinition?;

// ---------- Types
↑ StandardTypeName.ReferencedDeclaration: TypeDeclaration?;
= StandardTypeName.ReferencedDeclaration;
↓ StandardTypeName.IsAttributeType:`bool`;

// -------------------------------------------------------------------------------------------------
// Symbol Nodes
// -------------------------------------------------------------------------------------------------

// ---------- Parent
↑ ChildSymbol.Syntax: `ISyntax`? => null;

// ---------- Facets
= PackageFacetSymbol.*.**.SymbolTree => SymbolTree;
↑ child PackageFacetSymbol.GlobalNamespace: NamespaceSymbol;
= eager PackageFacetSymbol.GlobalNamespace;

// ---------- Type Symbol Nodes
= PrimitiveTypeSymbol.Supertypes => Symbol.GetDeclaredType()?.Supertypes ?? [];
// For now, the symbol tree already includes all inherited members.
= PrimitiveTypeSymbol.InclusiveMembers => Members;
↓ UserTypeSymbol.SymbolTree(): `ISymbolTree`;
= UserTypeSymbol.Supertypes => Symbol.GetDeclaredType().Supertypes;
// For now, the symbol tree already includes all inherited members.
= ClassSymbol.InclusiveMembers => Members;
= StructSymbol.InclusiveMembers => Members;
= TraitSymbol.InclusiveMembers => Members;

// ---------- Type Declaration Parts
= GenericParameterSymbol.Supertypes => Symbol.GetDeclaredType()?.Supertypes ?? [];
= GenericParameterSymbol.InclusiveMembers => [];

// ---------- Member Symbol Nodes
= StandardMethodSymbol.Arity => Symbol.Arity;
= StandardMethodSymbol.MethodGroupType => Symbol.MethodGroupType;
= FieldSymbol.BindingType => Symbol.Type;
