◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊root <default>;
◊prefix I;
◊suffix SymbolNode;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Framework;

<default> = Symbol:`Symbol`;
// Parent, Package, and GlobalNamespace type quoted so that is is not treated as a child node
Child <: `IChild<ISymbolNode>` = Parent:`ISymbolNode` Package:`IPackageSymbolNode`; 

// ---------- Packages
Package = AliasOrName:`IdentifierName`? Name:`IdentifierName` Symbol:`PackageSymbol`
    MainFacet:PackageFacet TestingFacet:PackageFacet;

PackageMember <: NamespaceMember;

// ---------- Facets
/// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacet <: Child = PackageAliasOrName:`IdentifierName`? PackageName:`IdentifierName` Symbol:`PackageSymbol`
    GlobalNamespace:Namespace;

// ---------- Declarations
Declaration <: Child = Name:`StandardName` Facet:`IPackageFacetSymbolNode`;
DeclarationWithMembers <: Declaration = Members:Declaration*;

// ---------- Namespaces
Namespace <: DeclarationWithMembers, NamespaceMember = Name:`IdentifierName` Symbol:`NamespaceSymbol` Members:NamespaceMember*;
NamespaceMember <: Declaration;

// ---------- Type Declarations
Type <: DeclarationWithMembers, PackageMember, ClassMember, TraitMember, StructMember
    = Symbol:`UserTypeSymbol` Members:TypeMember*;
Class <: Type = Members:ClassMember*;
Struct <: Type = Members:StructMember*;
Trait <: Type = Members:TraitMember*;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMember <: Declaration;
ClassMember <: TypeMember;
TraitMember <: TypeMember;
StructMember <: TypeMember;

// ---------- Invocable Declarations
Function <: PackageMember = Symbol:`FunctionSymbol`;
