◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics.Antetypes;
◊name ExpressionAntetypesAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Antetypes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Diagnostics;

// ↓ ⟳ ↑ ⮡ ↗↖ →*← ✎

// ---------- Special Parts
↑ BlockOrResult.Antetype: `IMaybeAntetype`;

// ---------- Function Parts
↓ ExpressionBody.ExpectedAntetype: `IMaybeExpressionAntetype`?;
= ExpressionBody.ResultStatement.ExpectedAntetype => ExpectedAntetype;

// ---------- Statements
↑ Statement.ResultAntetype: `IMaybeAntetype`? => null;
↓ ResultStatement.ExpectedAntetype: `IMaybeExpressionAntetype`?;
= ResultStatement.Expression.ExpectedAntetype => ExpectedAntetype;
= ResultStatement.ResultAntetype => Antetype;
// The expected antetype for the initializer is the binding antetype since it needs to
// have any conversion (e.g. to non-const-value type) applied.
= VariableDeclarationStatement.Initializer.ExpectedAntetype => BindingAntetype;
= ExpressionStatement.Expression.ExpectedAntetype => null;

// ---------- Patterns
= OptionalPattern.↑.Diagnostics;

// ---------- Expressions
// TODO remove once all nodes properly provide the expected antetype
= AmbiguousExpression.*.ExpectedAntetype => null;
↓ Expression.ExpectedAntetype: `IMaybeExpressionAntetype`?;
↑ Expression.Antetype: `IMaybeExpressionAntetype`;
✎ Expression ImplicitConversion;
↑ BlockExpression.Antetype: `IMaybeAntetype`;
// TODO it would be better if this didn't depend on types, but only on antetypes
= NewObjectExpression.Arguments[index].ExpectedAntetype
    => ContextualizedOverload?.ParameterTypes[index].Type.ToAntetype();
= NeverTypedExpression.Antetype => IAntetype.Never;

// ---------- Operator Expressions
↑ BinaryOperatorExpression.NumericOperatorCommonAntetype: `IAntetype`?;
= UnaryOperatorExpression.↑.Diagnostics;
= IdExpression.Antetype => Referent?.Antetype ?? IAntetype.Unknown;
= PatternMatchExpression.Antetype => IAntetype.Bool;

// ---------- Invocation Expressions
= UnresolvedInvocationExpression.Expression.ExpectedAntetype => null;
= UnknownInvocationExpression.Antetype => IAntetype.Unknown;

// ---------- Ambiguous Name Expressions
= MemberAccessExpression.*.**.ExpectedAntetype => null;

// ---------- Name Expressions
= NamespaceName.Antetype => IAntetype.Unknown;
= FunctionGroupName.Antetype => throw new NotImplementedException();
= FunctionName.*.ExpectedAntetype => null;
= MethodGroupName.Antetype => throw new NotImplementedException();
= TypeNameExpression.Antetype => IAntetype.Unknown;
= InitializerGroupName.Antetype => throw new NotImplementedException();
↑ InitializerGroupName.InitializingAntetype: `IMaybeAntetype` => Context.NamedAntetype;
= SpecialTypeNameExpression.Antetype => IAntetype.Unknown;
= MissingNameExpression.Antetype => IAntetype.Unknown;
= UnknownNameExpression.Antetype => IAntetype.Unknown;

// ---------- Capability Expressions
= MoveExpression.Antetype => Referent.Antetype;
= ImplicitTempMoveExpression.Antetype => Referent.Antetype;
= FreezeExpression.Antetype => Referent.Antetype;
= PrepareToReturnExpression.Antetype => Value.Antetype;

// ---------- Async Expressions
= AsyncBlockExpression.Antetype => Block.Antetype;
= AwaitExpression.↑.Diagnostics;
