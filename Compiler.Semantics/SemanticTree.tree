◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes.Model;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageDeclarationNode`;

// ---------- Special Parts
BodyOrBlock <: Code;
ElseClause <: Code;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding <: Code = IsMutableBinding:`bool`;
LocalBinding: Binding;

// ---------- Packages
Package <: PackageDeclaration = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    PackageDeclarations:`FixedDictionary<IdentifierName,IPackageDeclarationNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

// ---------- Facets
PackageFacet <: Child, PackageFacetDeclaration = Syntax:`IPackageSyntax` PackageName:`IdentifierName`
    Symbol:`PackageSymbol`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Definitions:`IFixedSet<IPackageMemberDefinitionNode>`
    GlobalNamespace:NamespaceDefinition;

// TODO rename to FacetMemberDefinition
PackageMemberDefinition <: NamespaceBlockMemberDefinition, NamespaceMemberDefinition
    = Attributes:Attribute* AccessModifier:`AccessModifier`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax`? File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingDeclaration:`IPackageFacetNode` ContainingSymbol:`PackageSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespace:`INamespaceDefinitionNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Definitions:NamespaceBlockMemberDefinition*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Definitions
Definition <: Code, PackageFacetChildDeclaration = Syntax:`IDefinitionSyntax`? Facet:`IPackageFacetNode`
    ContainingDeclaration:`ISymbolDeclarationNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`;
InvocableDefinition <: Definition = Parameters:ConstructorOrInitializerParameter*;
ConcreteInvocableDefinition <: InvocableDefinition = Parameters:ConstructorOrInitializerParameter*;

// ---------- Namespace Definitions
NamespaceBlockDefinition <: NamespaceBlockMemberDefinition = Syntax:`INamespaceDefinitionSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Members:NamespaceBlockMemberDefinition*
    Definition:`INamespaceDefinitionNode` ContainingDeclaration:`INamespaceDefinitionNode`
    ContainingNamespace:`INamespaceDefinitionNode` ContainingSymbol:`NamespaceSymbol`
    Symbol:`NamespaceSymbol` ContainingLexicalScope:`NamespaceSearchScope`;
NamespaceBlockMemberDefinition <: Definition;
NamespaceDefinition <: NamespaceMemberDefinition, NamespaceDeclaration
    = MemberNamespaces:NamespaceDefinition* PackageMembers:`IPackageMemberDefinitionNode`*
    Members:`INamespaceMemberDefinitionNode`*;
NamespaceMemberDefinition <: NamespaceMemberDeclaration;

// ---------- Function Definition
FunctionDefinition <: PackageMemberDefinition, FunctionDeclaration = Syntax:`IFunctionDefinitionSyntax`
    ContainingDeclaration:`INamespaceDeclarationNode` ContainingSymbol:`NamespaceSymbol`
    Attributes:Attribute* Name:`IdentifierName` Parameters:NamedParameter* Return:Type? Body
    Type:`FunctionType` Symbol:`FunctionSymbol`;

// ---------- Type Definitions
TypeDefinition <: PackageMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, UserTypeDeclaration
    = Syntax:`ITypeDefinitionSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:TypeMemberDefinition*;
ClassDefinition <: TypeDefinition, ClassDeclaration = Syntax:`IClassDefinitionSyntax`
    Attributes:Attribute* IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName*
    DeclaredType:`ObjectType`
    SourceMembers:`IClassMemberDefinitionNode`* Members:ClassMemberDefinition*
    DefaultConstructor:`IDefaultConstructorDefinitionNode`?;
StructDefinition <: TypeDefinition, StructDeclaration = Syntax:`IStructDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName*
    DeclaredType:`StructType`
    Members:StructMemberDefinition*;
TraitDefinition <: TypeDefinition, TraitDeclaration = Syntax:`ITraitDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName*
    DeclaredType:`ObjectType`
    Members:TraitMemberDefinition*;

// ---------- Type Definition Parts
GenericParameter <: Code, GenericParameterDeclaration = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingDeclaration:`IUserTypeDeclarationNode` ContainingSymbol:`UserTypeSymbol`
    Symbol:`GenericParameterTypeSymbol`;

// ---------- Type Member Definitions (i.e. definitions that can be contained in a type)
TypeMemberDefinition <: Definition, TypeMemberDeclaration = Syntax:`ITypeMemberDefinitionSyntax`? AccessModifier:`AccessModifier`;
ClassMemberDefinition <: TypeMemberDefinition, ClassMemberDeclaration = Syntax:`IClassMemberDefinitionSyntax`?;
TraitMemberDefinition <: TypeMemberDefinition, TraitMemberDeclaration = Syntax:`ITraitMemberDefinitionSyntax`;
StructMemberDefinition <: TypeMemberDefinition, StructMemberDeclaration = Syntax:`IStructMemberDefinitionSyntax`?;
AlwaysTypeMemberDefinition <: TypeMemberDefinition = ContainingSymbol:`UserTypeSymbol`;

// ---------- Member Definitions
MethodDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, InvocableDefinition, MethodDeclaration
    = Syntax:`IMethodDefinitionSyntax` Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    Symbol:`MethodSymbol`;
AbstractMethodDefinition <: MethodDefinition = Syntax:`IAbstractMethodDefinitionSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    ContainingDeclaredType:`ObjectType`;
ConcreteMethodDefinition <: MethodDefinition, StructMemberDefinition, ConcreteInvocableDefinition
    = Syntax:`IConcreteMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
StandardMethodDefinition <: ConcreteMethodDefinition = Syntax:`IStandardMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
GetterMethodDefinition <: ConcreteMethodDefinition = Syntax:`IGetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type Body;
SetterMethodDefinition <: ConcreteMethodDefinition = Syntax:`ISetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
ConstructorDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition, ConstructorDeclaration
    = Syntax:`IConstructorDefinitionSyntax`? Name:`IdentifierName`? Parameters:ConstructorOrInitializerParameter*
    Symbol:`ConstructorSymbol`;
DefaultConstructorDefinition <: ConstructorDefinition
    = Parameters:ConstructorOrInitializerParameter*;
SourceConstructorDefinition <: ConstructorDefinition
    = Syntax:`IConstructorDefinitionSyntax`
    SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter* Body:BlockBody;
InitializerDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, StructMemberDefinition, InitializerDeclaration
    = Syntax:`IInitializerDefinitionSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`InitializerSymbol` Body:BlockBody;
FieldDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, StructMemberDefinition, Binding, FieldDeclaration
    = Syntax:`IFieldDefinitionSyntax` IsMutableBinding:`bool` Name:`IdentifierName` TypeNode:Type Type:`DataType`
    Symbol:`FieldSymbol` Initializer:UntypedExpression?;
AssociatedFunctionDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, AssociatedFunctionDeclaration
    = Syntax:`IAssociatedFunctionDefinitionSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type?
   Symbol:`FunctionSymbol` Type:`FunctionType` Body;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:StandardTypeName ReferencedSymbol:`ConstructorSymbol`?;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax` Name:`IdentifierName`? Unused:`bool` Type:`Pseudotype`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax` Type:`DataType` ParameterType:`Parameter`;
NamedParameter <: ConstructorOrInitializerParameter = Syntax:`INamedParameterSyntax`
    IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`?
    TypeNode:Type;
SelfParameter <: Parameter = Syntax:`ISelfParameterSyntax` IsLentBinding:`bool` ContainingDeclaredType:`IDeclaredUserType`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ReferenceType` ContainingDeclaredType:`ObjectType`;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ValueType` ContainingDeclaredType:`StructType`;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` IsLentBinding:`bool` Capability:CapabilityConstraint
    ParameterType:`SelfParameter`;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax` Name:`IdentifierName`
    ContainingTypeDefinition:`ITypeDefinitionNode` ReferencedField:`IFieldDefinitionNode`?;

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body = Syntax:`IBlockBodySyntax` Statements:BodyStatement*;
ExpressionBody: Body = Syntax:`IExpressionBodySyntax` ResultStatement;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Type:`DataType`;
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` IsAttributeType:`bool` Name:`StandardName` ReferencedDeclaration:`ITypeDeclarationNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type SelfType:`Pseudotype`?;

// ---------- Statements
Statement <: Code = Syntax:`IStatementSyntax`;
ResultStatement: Statement <: BlockOrResult = Syntax:`IResultStatementSyntax` Expression:UntypedExpression;
BodyStatement: Statement = Syntax:`IBodyStatementSyntax`;
VariableDeclarationStatement <: BodyStatement, LocalBinding = Syntax:`IVariableDeclarationStatementSyntax`
    Name:`IdentifierName` Capability? Type? Initializer:UntypedExpression?;
ExpressionStatement: BodyStatement = Syntax:`IExpressionStatementSyntax` Expression:UntypedExpression;

// ---------- Patterns
Pattern <: Code = Syntax:`IPatternSyntax`;
BindingContextPattern <: Pattern = Syntax:`IBindingContextPatternSyntax` IsMutableBinding:`bool` Pattern Type?;
OptionalOrBindingPattern <: Pattern = Syntax:`IOptionalOrBindingPatternSyntax`;
BindingPattern <: OptionalOrBindingPattern, LocalBinding = Syntax:`IBindingPatternSyntax` Name:`IdentifierName`;
OptionalPattern <: OptionalOrBindingPattern = Syntax:`IOptionalPatternSyntax` Pattern:OptionalOrBindingPattern;

// ---------- Expressions
UntypedExpression <: Code = Syntax:`IExpressionSyntax`;
Expression <: UntypedExpression = Syntax:`ITypedExpressionSyntax`;
AssignableExpression <: Expression = Syntax:`IAssignableExpressionSyntax`;
BlockExpression <: Expression, BlockOrResult, BodyOrBlock = Syntax:`IBlockExpressionSyntax` Statements:Statement*;
NewObjectExpression <: Expression = Syntax:`INewObjectExpressionSyntax` Type:TypeName ConstructorName:`IdentifierName`? Arguments:UntypedExpression* ReferencedSymbol:`ConstructorSymbol?`;
UnsafeExpression <: Expression = Syntax:`IUnsafeExpressionSyntax` Expression:UntypedExpression;
NeverTypedExpression <: Expression = Syntax:`INeverTypedExpressionSyntax` Type:`NeverType`;

// ---------- Literal Expressions
LiteralExpression <: Expression = Syntax:`ILiteralExpressionSyntax`;
BoolLiteralExpression <: LiteralExpression = Syntax:`IBoolLiteralExpressionSyntax` Value:`bool` Type:`BoolConstValueType`;
IntegerLiteralExpression <: LiteralExpression = Syntax:`IIntegerLiteralExpressionSyntax` Value:`BigInteger` Type:`IntegerConstValueType`;
NoneLiteralExpression <: LiteralExpression = Syntax:`INoneLiteralExpressionSyntax` Type:`OptionalType`;
StringLiteralExpression <: LiteralExpression = Syntax:`IStringLiteralExpressionSyntax`
    Value:`string` Type:`DataType` ContainingLexicalScope:`LexicalScope`;

// ---------- Operator Expressions
AssignmentExpression <: Expression = Syntax:`IAssignmentExpressionSyntax` LeftOperand:AssignableExpression Operator:`AssignmentOperator` RightOperand:UntypedExpression;
BinaryOperatorExpression <: Expression = Syntax:`IBinaryOperatorExpressionSyntax` LeftOperand:UntypedExpression Operator:`BinaryOperator` RightOperand:UntypedExpression;
UnaryOperatorExpression <: Expression = Syntax:`IUnaryOperatorExpressionSyntax` Fixity:`UnaryOperatorFixity` Operator:`UnaryOperator` Operand:UntypedExpression;
IdExpression <: Expression = Syntax:`IIdExpressionSyntax` Referent:UntypedExpression;
ConversionExpression <: Expression = Syntax:`IConversionExpressionSyntax` Referent:UntypedExpression Operator:`ConversionOperator` ConvertToType:Type;
PatternMatchExpression <: Expression = Syntax:`IPatternMatchExpressionSyntax` Referent:UntypedExpression Pattern;

// ---------- Control Flow Expressions
IfExpression <: Expression, ElseClause = Syntax:`IIfExpressionSyntax` Condition:UntypedExpression ThenBlock:BlockOrResult ElseClause?;
LoopExpression <: Expression = Syntax:`ILoopExpressionSyntax` Block:BlockExpression;
WhileExpression <: Expression = Syntax:`IWhileExpressionSyntax` Condition:UntypedExpression Block:BlockExpression;
ForeachExpression <: Expression, LocalBinding = Syntax:`IForeachExpressionSyntax` VariableName:`IdentifierName` InExpression:UntypedExpression Type? Block:BlockExpression;
BreakExpression <: NeverTypedExpression = Syntax:`IBreakExpressionSyntax` Value:UntypedExpression?;
NextExpression <: NeverTypedExpression = Syntax:`INextExpressionSyntax`;
ReturnExpression <: NeverTypedExpression = Syntax:`IReturnExpressionSyntax` Value:UntypedExpression?;

// ---------- Invocation Expressions
InvocationExpression <: Expression = Syntax:`IInvocationExpressionSyntax` Expression:UntypedExpression Arguments:UntypedExpression*;

// ---------- Name Expressions
NameExpression <: UntypedExpression = Syntax:`INameExpressionSyntax`;
InvocableNameExpression <: NameExpression = Syntax:`IInvocableNameExpressionSyntax`;
VariableNameExpression <: NameExpression = Syntax:`IVariableNameExpressionSyntax`;
StandardNameExpression <: NameExpression = Syntax:`IStandardNameExpressionSyntax` Name:`StandardName`? ReferencedSymbol:`Symbol?`;
SimpleNameExpression <: NameExpression = Syntax:`ISimpleNameExpressionSyntax`;
IdentifierNameExpression <: NameExpression, InvocableNameExpression, SimpleNameExpression, StandardNameExpression, VariableNameExpression, AssignableExpression
    = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName`?;
SpecialTypeNameExpression <: NameExpression, SimpleNameExpression
    = Syntax:`ISpecialTypeNameExpressionSyntax` Name:`SpecialTypeName` ReferencedSymbol:`TypeSymbol`?;
GenericNameExpression <: NameExpression, InvocableNameExpression, StandardNameExpression
    = Syntax:`IGenericNameExpressionSyntax` Name:`GenericName` TypeArguments:Type*;
MemberAccessExpression <: NameExpression, InvocableNameExpression, AssignableExpression
    = Syntax:`IMemberAccessExpressionSyntax` Context:UntypedExpression AccessOperator:`AccessOperator` MemberName:`StandardName` TypeArguments:Type*;
SelfExpression <: NameExpression, VariableNameExpression, Expression
    = Syntax:`ISelfExpressionSyntax` IsImplicit:`bool` Pseudotype:`Pseudotype`;
MissingNameExpression <: NameExpression, VariableNameExpression, AssignableExpression, Expression
    = Syntax:`IIdentifierNameExpressionSyntax` Type:`UnknownType`;

// ---------- Capability Expressions
MoveExpression <: Expression = Syntax:`IMoveExpressionSyntax` Referent:VariableNameExpression;
FreezeExpression <: Expression = Syntax:`IFreezeExpressionSyntax` Referent:VariableNameExpression;

// ---------- Async Expressions
AsyncBlockExpression <: Expression = Syntax:`IAsyncBlockExpressionSyntax` Block:BlockExpression;
AsyncStartExpression <: Expression = Syntax:`IAsyncStartExpressionSyntax` Scheduled:`bool` Expression:UntypedExpression;
AwaitExpression <: Expression = Syntax:`IAwaitExpressionSyntax` Expression:UntypedExpression;


// -------------------------------------------------------------------------------------------------
// Declarations
// -------------------------------------------------------------------------------------------------
// Declarations are the abstractions of both definitions an symbols. They are used to represent what
// a name can refer to.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

Declaration;
ChildDeclaration <: Declaration, Child;
NamedDeclaration <: ChildDeclaration = Name:`StandardName`;
SymbolDeclaration <: Declaration = Symbol:`Symbol`;

// ---------- Bindings
BindingDeclaration <: NamedDeclaration = Name:`IdentifierName`;
LocalBindingDeclaration <: BindingDeclaration;

// ---------- Packages
PackageDeclaration <: SymbolDeclaration = AliasOrName:`IdentifierName`? Name:`IdentifierName` Symbol:`PackageSymbol`
    MainFacet:PackageFacetDeclaration TestingFacet:PackageFacetDeclaration;

PackageMemberDeclaration <: NamespaceMemberDeclaration;

// ---------- Facets
/// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacetDeclaration <: ChildDeclaration, SymbolDeclaration
    = PackageAliasOrName:`IdentifierName`? PackageName:`IdentifierName`
    Symbol:`PackageSymbol` GlobalNamespace:NamespaceDeclaration;

PackageFacetChildDeclaration <: ChildDeclaration
    = Name:`StandardName`? Facet:`IPackageFacetDeclarationNode`;

// ---------- Namespace Declarations
NamespaceDeclaration <: NamespaceMemberDeclaration = Name:`IdentifierName` Symbol:`NamespaceSymbol`
    Members:`INamespaceMemberDeclarationNode`* NestedMembers:`INamespaceMemberDeclarationNode`*;
NamespaceMemberDeclaration <: PackageFacetChildDeclaration, NamedDeclaration, SymbolDeclaration;

// ---------- Function Declaration
FunctionDeclaration <: PackageMemberDeclaration, NamedDeclaration = Symbol:`FunctionSymbol`;

// ---------- Type Declarations
UserTypeDeclaration <: PackageMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, TypeDeclaration, NamedDeclaration
    = Symbol:`UserTypeSymbol` Members:TypeMemberDeclaration*;
ClassDeclaration <: UserTypeDeclaration = Members:ClassMemberDeclaration*;
StructDeclaration <: UserTypeDeclaration = Members:StructMemberDeclaration*;
TraitDeclaration <: UserTypeDeclaration = Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameterDeclaration <: TypeDeclaration = Name:`IdentifierName`;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: PackageFacetChildDeclaration, SymbolDeclaration;
ClassMemberDeclaration <: TypeMemberDeclaration;
TraitMemberDeclaration <: TypeMemberDeclaration;
StructMemberDeclaration <: TypeMemberDeclaration;

// ---------- Member Declarations
MethodDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, NamedDeclaration = Name:`IdentifierName` Symbol:`MethodSymbol`;
ConstructorDeclaration <: ClassMemberDeclaration = Name:`IdentifierName`? Symbol:`ConstructorSymbol`;
InitializerDeclaration <: StructMemberDeclaration = Name:`IdentifierName`? Symbol:`InitializerSymbol`;
FieldDeclaration <: NamedDeclaration, ClassMemberDeclaration, StructMemberDeclaration = Name:`IdentifierName` Type:`DataType` Symbol:`FieldSymbol`;
AssociatedFunctionDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, NamedDeclaration
    = Name:`IdentifierName` Symbol:`FunctionSymbol` Type:`FunctionType`;

// ---------- Can be Referenced by Type Name
TypeDeclaration <: NamedDeclaration, SymbolDeclaration = Symbol:`TypeSymbol`;

// -------------------------------------------------------------------------------------------------
// Symbol Nodes
// -------------------------------------------------------------------------------------------------
// Implementations of declarations that are derived from symbols.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

// ---------- Packages
PackageSymbol <: PackageDeclaration = MainFacet:PackageFacetDeclaration TestingFacet:PackageFacetDeclaration;

// ---------- Facets
// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacetSymbol <: PackageFacetDeclaration = GlobalNamespace:NamespaceDeclaration;

// ---------- Namespace Declarations
NamespaceSymbol <: NamespaceDeclaration = Members:NamespaceMemberDeclaration*;

// ---------- Function Declaration
FunctionSymbol <: FunctionDeclaration;

// ---------- Type Declarations
UserTypeSymbol <: UserTypeDeclaration = Members:TypeMemberDeclaration*;
ClassSymbol <: ClassDeclaration = Members:ClassMemberDeclaration*;
StructSymbol <: StructDeclaration = Members:StructMemberDeclaration*;
TraitSymbol <: TraitDeclaration = Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameterSymbol <: GenericParameterDeclaration;

// ---------- Member Declarations
MethodSymbol <: MethodDeclaration;
ConstructorSymbol <: ConstructorDeclaration;
InitializerSymbol <: InitializerDeclaration;
FieldSymbol <: FieldDeclaration;
AssociatedFunctionSymbol <: AssociatedFunctionDeclaration;
