◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using System.Collections.Generic;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Antetypes;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Types.Flow;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageDeclarationNode`;

// ---------- Special Parts
BodyOrBlock <: Code = Statements:`IStatementNode`*;
ElseClause <: Code;
BlockOrResult: ElseClause = Antetype:`IMaybeAntetype`;

// ---------- Bindings
Binding <: Code, BindingDeclaration;
NamedBinding <: Binding, NamedBindingDeclaration = Syntax:`ILocalBindingSyntax` ValueId:`ValueId`
    BindingAntetype:`IMaybeAntetype`;

// ---------- Packages
Package <: PackageDeclaration = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    PackageDeclarations:`FixedDictionary<IdentifierName,IPackageDeclarationNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*
    PrimitivesDeclarations:{TypeDeclaration};

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

// ---------- Facets
PackageFacet <: Child, PackageFacetDeclaration = Syntax:`IPackageSyntax`
    PackageName:`IdentifierName` PackageSymbol:`PackageSymbol`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Definitions:`IFixedSet<IPackageMemberDefinitionNode>`
    GlobalNamespace:NamespaceDefinition;

// TODO rename to FacetMemberDefinition
PackageMemberDefinition <: NamespaceBlockMemberDefinition, NamespaceMemberDefinition
    = Attributes:Attribute* AccessModifier:`AccessModifier`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax`? File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingDeclaration:`IPackageFacetNode` ContainingSymbol:`PackageSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespace:`INamespaceDefinitionNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Definitions:NamespaceBlockMemberDefinition*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Definitions
Definition <: Code, PackageFacetChildDeclaration = Syntax:`IDefinitionSyntax`? Facet:`IPackageFacetNode`
    ContainingDeclaration:`ISymbolDeclarationNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`;
InvocableDefinition <: Definition = Parameters:ConstructorOrInitializerParameter* Symbol:`InvocableSymbol` ValueIdScope:`ValueIdScope`;
ExecutableDefinition <: Definition = ValueIdScope:`ValueIdScope`;
ConcreteInvocableDefinition <: InvocableDefinition, ExecutableDefinition
    = Parameters:ConstructorOrInitializerParameter*;

// ---------- Namespace Definitions
NamespaceBlockDefinition <: NamespaceBlockMemberDefinition = Syntax:`INamespaceDefinitionSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Members:NamespaceBlockMemberDefinition*
    Definition:`INamespaceDefinitionNode` ContainingDeclaration:`INamespaceDefinitionNode`
    ContainingNamespace:`INamespaceDefinitionNode` ContainingSymbol:`NamespaceSymbol`
    Symbol:`NamespaceSymbol` ContainingLexicalScope:`NamespaceSearchScope`;
NamespaceBlockMemberDefinition <: Definition;
NamespaceDefinition <: NamespaceMemberDefinition, NamespaceDeclaration
    = MemberNamespaces:NamespaceDefinition* PackageMembers:`IPackageMemberDefinitionNode`*
    Members:`INamespaceMemberDefinitionNode`*;
NamespaceMemberDefinition <: NamespaceMemberDeclaration;

// ---------- Function Definition
FunctionDefinition <: PackageMemberDefinition, FunctionDeclaration, ConcreteInvocableDefinition
    = Syntax:`IFunctionDefinitionSyntax`
    ContainingDeclaration:`INamespaceDeclarationNode` ContainingSymbol:`NamespaceSymbol`
    Attributes:Attribute* Name:`IdentifierName` Parameters:NamedParameter* Return:Type? Body
    Type:`FunctionType` Symbol:`FunctionSymbol`;

// ---------- Type Definitions
TypeDefinition <: PackageMemberDefinition, AssociatedMemberDefinition, UserTypeDeclaration
    = Syntax:`ITypeDefinitionSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:{TypeMemberDefinition};
ClassDefinition <: TypeDefinition, ClassDeclaration = Syntax:`IClassDefinitionSyntax`
    Attributes:Attribute* IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName*
    DeclaredType:`ObjectType`
    SourceMembers:`IClassMemberDefinitionNode`* Members:{ClassMemberDefinition}
    DefaultConstructor:`IDefaultConstructorDefinitionNode`?;
StructDefinition <: TypeDefinition, StructDeclaration = Syntax:`IStructDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName*
    DeclaredType:`StructType`
    Members:{StructMemberDefinition};
TraitDefinition <: TypeDefinition, TraitDeclaration = Syntax:`ITraitDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName*
    DeclaredType:`ObjectType`
    Members:{TraitMemberDefinition};

// ---------- Type Definition Parts
GenericParameter <: Code, GenericParameterDeclaration = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingDeclaration:`IUserTypeDeclarationNode` ContainingSymbol:`UserTypeSymbol`
    Symbol:`GenericParameterTypeSymbol` Members:{TypeMemberDefinition};

// ---------- Type Member Definitions (i.e. definitions that can be contained in a type)
TypeMemberDefinition <: Definition, TypeMemberDeclaration = Syntax:`ITypeMemberDefinitionSyntax`? AccessModifier:`AccessModifier`;
ClassMemberDefinition <: TypeMemberDefinition, ClassMemberDeclaration = Syntax:`IClassMemberDefinitionSyntax`?;
TraitMemberDefinition <: TypeMemberDefinition, TraitMemberDeclaration = Syntax:`ITraitMemberDefinitionSyntax`;
StructMemberDefinition <: TypeMemberDefinition, StructMemberDeclaration = Syntax:`IStructMemberDefinitionSyntax`?;
AlwaysTypeMemberDefinition <: TypeMemberDefinition = ContainingSymbol:`UserTypeSymbol`;
AssociatedMemberDefinition <: ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, NamedDeclaration;

// ---------- Member Definitions
MethodDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, InvocableDefinition, MethodDeclaration
    = Syntax:`IMethodDefinitionSyntax` Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    Symbol:`MethodSymbol`;
AbstractMethodDefinition <: MethodDefinition = Syntax:`IAbstractMethodDefinitionSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    ContainingDeclaredType:`ObjectType`;
ConcreteMethodDefinition <: MethodDefinition, StructMemberDefinition, ConcreteInvocableDefinition
    = Syntax:`IConcreteMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
StandardMethodDefinition <: ConcreteMethodDefinition, StandardMethodDeclaration
    = Syntax:`IStandardMethodDefinitionSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter*
    Return:Type? Body;
GetterMethodDefinition <: ConcreteMethodDefinition, GetterMethodDeclaration = Syntax:`IGetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type Body;
SetterMethodDefinition <: ConcreteMethodDefinition, SetterMethodDeclaration = Syntax:`ISetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
ConstructorDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition, ConstructorDeclaration
    = Syntax:`IConstructorDefinitionSyntax`? Name:`IdentifierName`? Parameters:ConstructorOrInitializerParameter*
    Symbol:`ConstructorSymbol`;
DefaultConstructorDefinition <: ConstructorDefinition
    = Parameters:ConstructorOrInitializerParameter*;
SourceConstructorDefinition <: ConstructorDefinition
    = Syntax:`IConstructorDefinitionSyntax`
    SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter* Body:BlockBody;
InitializerDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, StructMemberDefinition, InitializerDeclaration
    = Syntax:`IInitializerDefinitionSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`InitializerSymbol` Body:BlockBody;
FieldDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, StructMemberDefinition, Binding, FieldDeclaration, ExecutableDefinition
    = Syntax:`IFieldDefinitionSyntax` IsMutableBinding:`bool` Name:`IdentifierName` TypeNode:Type Antetype:`IMaybeAntetype` Type:`DataType`
    Symbol:`FieldSymbol` Initializer:AmbiguousExpression?;
AssociatedFunctionDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, AssociatedMemberDefinition, AssociatedFunctionDeclaration
    = Syntax:`IAssociatedFunctionDefinitionSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type?
   Symbol:`FunctionSymbol` Type:`FunctionType` Body;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:StandardTypeName ReferencedSymbol:`ConstructorSymbol`?;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability`;

// ---------- Parameters
Parameter <: Code, Binding = Syntax:`IParameterSyntax` Name:`IdentifierName`? Unused:`bool`
    Antetype:`IMaybeAntetype` Type:`Pseudotype` ValueId:`ValueId` FlowStateAfter:`FlowState`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax`
    Type:`DataType` ParameterType:`Parameter`;
NamedParameter <: ConstructorOrInitializerParameter, NamedBinding = Syntax:`INamedParameterSyntax`
    IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`?
    TypeNode:Type
    // TODO remove parameter symbols
    Symbol:`NamedVariableSymbol`;
SelfParameter <: Parameter = Syntax:`ISelfParameterSyntax` IsLentBinding:`bool`
    ContainingTypeDefinition:`ITypeDefinitionNode` ContainingDeclaredType:`IDeclaredUserType`
    // TODO remove parameter symbols
    Symbol:`SelfParameterSymbol`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`CapabilityType` ContainingDeclaredType:`ObjectType`;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`CapabilityType` ContainingDeclaredType:`StructType`;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` IsLentBinding:`bool` Capability:CapabilityConstraint
    ParameterType:`SelfParameter`;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax` Name:`IdentifierName`
    ContainingTypeDefinition:`ITypeDefinitionNode` ReferencedField:`IFieldDefinitionNode`?;

// ---------- Function Parts
Body: BodyOrBlock = FlowStateAfter:`FlowState`;
BlockBody: Body = Syntax:`IBlockBodySyntax` Statements:BodyStatement*;
ExpressionBody: Body = Syntax:`IExpressionBodySyntax` ResultStatement;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Antetype:`IMaybeAntetype` Type:`DataType`;
// TODO start from generalized names in syntax and rewrite to type names
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` IsAttributeType:`bool` Name:`StandardName` ReferencedDeclaration:`ITypeDeclarationNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type SelfType:`Pseudotype`?;

// ---------- Statements
Statement <: Code = Syntax:`IStatementSyntax` ResultAntetype:`IMaybeAntetype`? FlowStateAfter:`FlowState`;
ResultStatement: Statement <: BlockOrResult = Syntax:`IResultStatementSyntax` Expression:AmbiguousExpression
    FinalExpression:`IExpressionNode`;
BodyStatement: Statement = Syntax:`IBodyStatementSyntax`;
VariableDeclarationStatement <: BodyStatement, NamedBinding = Syntax:`IVariableDeclarationStatementSyntax`
    IsMutableBinding:`bool` Name:`IdentifierName` Capability? Type? Initializer:AmbiguousExpression?
    FinalInitializer:`IExpressionNode`?
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`
    // TODO remove variable symbols
    Symbol:`NamedVariableSymbol` DeclarationNumber:`int`?;
ExpressionStatement: BodyStatement = Syntax:`IExpressionStatementSyntax` Expression:AmbiguousExpression;

// ---------- Patterns
Pattern <: Code = Syntax:`IPatternSyntax`;
BindingContextPattern <: Pattern = Syntax:`IBindingContextPatternSyntax` IsMutableBinding:`bool` Pattern Type?;
OptionalOrBindingPattern <: Pattern = Syntax:`IOptionalOrBindingPatternSyntax`;
BindingPattern <: OptionalOrBindingPattern, NamedBinding = Syntax:`IBindingPatternSyntax`
    IsMutableBinding:`bool` Name:`IdentifierName` ContainingLexicalScope:`LexicalScope` ValueId:`ValueId`;
OptionalPattern <: OptionalOrBindingPattern = Syntax:`IOptionalPatternSyntax` Pattern:OptionalOrBindingPattern;

// ---------- Expressions
AmbiguousExpression <: Code = Syntax:`IExpressionSyntax`;
Expression <: AmbiguousExpression = Syntax:`IExpressionSyntax` ValueId:`ValueId` Antetype:`IMaybeExpressionAntetype`
    Type:`DataType` FlowStateAfter:`FlowState`;
AssignableExpression <: Expression = Syntax:`IAssignableExpressionSyntax`;
BlockExpression <: Expression, BlockOrResult, BodyOrBlock = Syntax:`IBlockExpressionSyntax` Statements:Statement*;
NewObjectExpression <: Expression = Syntax:`INewObjectExpressionSyntax`
    ConstructingType:TypeName ConstructorName:`IdentifierName`? Arguments:AmbiguousExpression*
    ConstructingAntetype:`IMaybeAntetype` ReferencedConstructors:{`IConstructorDeclarationNode`}
    CompatibleConstructors:{`IConstructorDeclarationNode`} ReferencedConstructor:`IConstructorDeclarationNode`?;
UnsafeExpression <: Expression = Syntax:`IUnsafeExpressionSyntax` Expression:AmbiguousExpression FinalExpression:`IExpressionNode`;
NeverTypedExpression <: Expression = Syntax:`INeverTypedExpressionSyntax` Type:`NeverType`;

// ---------- Literal Expressions
LiteralExpression <: Expression = Syntax:`ILiteralExpressionSyntax`;
BoolLiteralExpression <: LiteralExpression = Syntax:`IBoolLiteralExpressionSyntax` Value:`bool` Type:`BoolConstValueType`;
IntegerLiteralExpression <: LiteralExpression = Syntax:`IIntegerLiteralExpressionSyntax` Value:`BigInteger` Type:`IntegerConstValueType`;
NoneLiteralExpression <: LiteralExpression = Syntax:`INoneLiteralExpressionSyntax` Type:`OptionalType`;
StringLiteralExpression <: LiteralExpression = Syntax:`IStringLiteralExpressionSyntax`
    Value:`string` Type:`DataType` ContainingLexicalScope:`LexicalScope`;

// ---------- Operator Expressions
AssignmentExpression <: Expression = Syntax:`IAssignmentExpressionSyntax` LeftOperand:AssignableExpression Operator:`AssignmentOperator` RightOperand:AmbiguousExpression;
BinaryOperatorExpression <: Expression = Syntax:`IBinaryOperatorExpressionSyntax`
    LeftOperand:AmbiguousExpression FinalLeftOperand:`IExpressionNode`
    Operator:`BinaryOperator`
    RightOperand:AmbiguousExpression FinalRightOperand:`IExpressionNode`
    ContainingLexicalScope:`LexicalScope`;
UnaryOperatorExpression <: Expression = Syntax:`IUnaryOperatorExpressionSyntax` Fixity:`UnaryOperatorFixity`
    Operator:`UnaryOperator` Operand:AmbiguousExpression FinalOperand:`IExpressionNode`;
IdExpression <: Expression = Syntax:`IIdExpressionSyntax` Referent:AmbiguousExpression FinalReferent:`IExpressionNode`;
ConversionExpression <: Expression = Syntax:`IConversionExpressionSyntax` Referent:AmbiguousExpression Operator:`ConversionOperator` ConvertToType:Type;
PatternMatchExpression <: Expression = Syntax:`IPatternMatchExpressionSyntax` Referent:AmbiguousExpression Pattern;

// ---------- Control Flow Expressions
IfExpression <: Expression, ElseClause = Syntax:`IIfExpressionSyntax` Condition:AmbiguousExpression ThenBlock:BlockOrResult ElseClause?;
LoopExpression <: Expression = Syntax:`ILoopExpressionSyntax` Block:BlockExpression;
WhileExpression <: Expression = Syntax:`IWhileExpressionSyntax` Condition:AmbiguousExpression Block:BlockExpression;
ForeachExpression <: Expression, NamedBinding = Syntax:`IForeachExpressionSyntax`
    IsMutableBinding:`bool` VariableName:`IdentifierName` InExpression:AmbiguousExpression
    FinalInExpression:`IExpressionNode` DeclaredType:Type? Block:BlockExpression
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`
    ReferencedIterableDeclaration:`ITypeDeclarationNode`? ReferencedIterateMethod:`IStandardMethodDeclarationNode`?
    IteratorAntetype:`IMaybeExpressionAntetype`
    ReferencedIteratorDeclaration:`ITypeDeclarationNode`? ReferencedNextMethod:`IStandardMethodDeclarationNode`?
    IteratedAntetype:`IMaybeAntetype`;
BreakExpression <: NeverTypedExpression = Syntax:`IBreakExpressionSyntax` Value:AmbiguousExpression?;
NextExpression <: NeverTypedExpression = Syntax:`INextExpressionSyntax`;
ReturnExpression <: NeverTypedExpression = Syntax:`IReturnExpressionSyntax` Value:AmbiguousExpression?;

// ---------- Invocation Expressions
InvocationExpression <: AmbiguousExpression = Syntax:`IInvocationExpressionSyntax`
    Expression:AmbiguousExpression Arguments:AmbiguousExpression* CurrentArguments:`IEnumerable<IAmbiguousExpressionNode>`;
FunctionInvocationExpression <: Expression = Syntax:`IInvocationExpressionSyntax`
    FunctionGroup:FunctionGroupName Arguments:AmbiguousExpression*
    CompatibleDeclarations:{`IFunctionLikeDeclarationNode`} ReferencedDeclaration:`IFunctionLikeDeclarationNode`?;
MethodInvocationExpression <: Expression = Syntax:`IInvocationExpressionSyntax`
    MethodGroup:MethodGroupName Arguments:AmbiguousExpression*
    CompatibleDeclarations:{`IStandardMethodDeclarationNode`} ReferencedDeclaration:`IStandardMethodDeclarationNode`?;

// ---------- Ambiguous Name Expressions
AmbiguousNameExpression <: AmbiguousExpression = Syntax:`INameExpressionSyntax`;
AmbiguousName <: AmbiguousNameExpression;
SimpleName <: AmbiguousName = Syntax:`ISimpleNameSyntax`;
StandardNameExpression <: AmbiguousName = Syntax:`IStandardNameExpressionSyntax`
    Name:`StandardName` ContainingLexicalScope:`LexicalScope` ReferencedDeclarations:`IDeclarationNode`*;
IdentifierNameExpression <: AmbiguousName, StandardNameExpression, SimpleName, AssignableExpression
    = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName`;
GenericNameExpression <: AmbiguousName, StandardNameExpression
    = Syntax:`IGenericNameExpressionSyntax` Name:`GenericName` TypeArguments:Type*;
MemberAccessExpression <: AmbiguousName, AssignableExpression
    = Syntax:`IMemberAccessExpressionSyntax` Context:AmbiguousExpression MemberName:`StandardName` TypeArguments:Type*;

// ---------- Name Expressions
NameExpression <: Expression, AmbiguousNameExpression = Syntax:`INameExpressionSyntax`;
// TODO Name <: NameExpression
NamespaceName <: NameExpression = Type:`UnknownType` ReferencedDeclarations:`INamespaceDeclarationNode`*;
UnqualifiedNamespaceName <: NamespaceName = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName`;
QualifiedNamespaceName <: NamespaceName = Syntax:`IMemberAccessExpressionSyntax` Context:NamespaceName Name:`IdentifierName`;
FunctionGroupName <: NameExpression = Context:NameExpression? FunctionName:`StandardName` TypeArguments:Type*
    ReferencedDeclarations:{`IFunctionLikeDeclarationNode`};
MethodGroupName <: NameExpression = Syntax:`IMemberAccessExpressionSyntax` Context:Expression MethodName:`StandardName` TypeArguments:Type*
    ReferencedDeclarations:{`IStandardMethodDeclarationNode`};
FieldAccessExpression <: NameExpression, AssignableExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:Expression FieldName:`IdentifierName` ReferencedDeclaration:`IFieldDeclarationNode`;
VariableNameExpression <: NameExpression, AssignableExpression, SimpleName
    = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName` ReferencedDeclaration:`INamedBindingNode`;
TypeNameExpression <: NameExpression = Syntax:`INameExpressionSyntax`
    Name:`StandardName` TypeArguments:Type* ReferencedDeclaration:`ITypeDeclarationNode`;
StandardTypeNameExpression <: TypeNameExpression = Syntax:`IStandardNameExpressionSyntax` TypeArguments:Type*;
QualifiedTypeNameExpression <: TypeNameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:NamespaceName TypeArguments:Type*;
InitializerGroupName <: NameExpression = Syntax:`IMemberAccessExpressionSyntax` Context:TypeNameExpression? InitializerName:`StandardName`
    ReferencedDeclarations:{`IInitializerDeclarationNode`};
// TODO merge with SpecialTypeName and keep the name "SpecialTypeName" because it really isn't an expression
SpecialTypeNameExpression <: NameExpression
    = Syntax:`ISpecialTypeNameExpressionSyntax` Name:`SpecialTypeName` ReferencedSymbol:`TypeSymbol` Type:`UnknownType`;
InstanceExpression <: NameExpression, SimpleName; // i.e. `self` or `base`
// TODO BaseExpression <: InstanceExpression
SelfExpression <: InstanceExpression
    = Syntax:`ISelfExpressionSyntax` IsImplicit:`bool` Pseudotype:`Pseudotype`
    ContainingDeclaration:`IExecutableDefinitionNode` ReferencedParameter:`ISelfParameterNode`? ReferencedSymbol:`SelfParameterSymbol`?;
MissingNameExpression <: NameExpression, SimpleName, AssignableExpression
    = Syntax:`IMissingNameSyntax` Type:`UnknownType`;
UnknownNameExpression <: NameExpression = Syntax:`INameExpressionSyntax` Type:`UnknownType`;
UnknownStandardNameExpression <: UnknownNameExpression
    = Syntax:`IStandardNameExpressionSyntax` Name:`StandardName` ReferencedDeclarations:{`IDeclarationNode`};
UnknownIdentifierNameExpression <: UnknownStandardNameExpression, SimpleName, AssignableExpression
    = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName`;
UnknownGenericNameExpression <: UnknownStandardNameExpression
    = Syntax:`IGenericNameExpressionSyntax` Name:`GenericName` TypeArguments:Type*;
UnknownMemberAccessExpression <: UnknownNameExpression, AssignableExpression
    = Syntax:`IMemberAccessExpressionSyntax` Context:Expression MemberName:`StandardName` TypeArguments:Type*
    ReferencedMembers:{`IDeclarationNode`};

// ---------- Capability Expressions
MoveExpression <: Expression = Syntax:`IMoveExpressionSyntax` Referent:SimpleName FinalReferent:`INameExpressionNode`;
FreezeExpression <: Expression = Syntax:`IFreezeExpressionSyntax` Referent:SimpleName FinalReferent:`INameExpressionNode`;

// ---------- Async Expressions
AsyncBlockExpression <: Expression = Syntax:`IAsyncBlockExpressionSyntax` Block:BlockExpression;
AsyncStartExpression <: Expression = Syntax:`IAsyncStartExpressionSyntax` Scheduled:`bool`
    Expression:AmbiguousExpression FinalExpression:`IExpressionNode`;
AwaitExpression <: Expression = Syntax:`IAwaitExpressionSyntax`
    Expression:AmbiguousExpression  FinalExpression:`IExpressionNode`;


// -------------------------------------------------------------------------------------------------
// Declarations
// -------------------------------------------------------------------------------------------------
// Declarations are the abstractions of both definitions and symbols. They are used to represent
// what a name can refer to.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

Declaration;
ChildDeclaration <: Declaration, Child;
NamedDeclaration <: ChildDeclaration = Name:`TypeName`;
SymbolDeclaration <: Declaration = Symbol:`Symbol`;
InvocableDeclaration <: SymbolDeclaration, ChildDeclaration = Symbol:`InvocableSymbol`;

// ---------- Bindings
BindingDeclaration <: ChildDeclaration;
NamedBindingDeclaration <: BindingDeclaration, NamedDeclaration = Name:`IdentifierName`;

// ---------- Packages
PackageDeclaration <: SymbolDeclaration = AliasOrName:`IdentifierName`? Name:`IdentifierName` Symbol:`PackageSymbol`
    MainFacet:PackageFacetDeclaration TestingFacet:PackageFacetDeclaration;

PackageMemberDeclaration <: NamespaceMemberDeclaration;

// ---------- Facets
/// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacetDeclaration <: ChildDeclaration, SymbolDeclaration
    = PackageAliasOrName:`IdentifierName`? PackageName:`IdentifierName`
    Symbol:`PackageSymbol` GlobalNamespace:NamespaceDeclaration;

PackageFacetChildDeclaration <: ChildDeclaration
    = Name:`StandardName`? Facet:`IPackageFacetDeclarationNode`;

// ---------- Namespace Declarations
NamespaceDeclaration <: NamespaceMemberDeclaration = Name:`IdentifierName` Symbol:`NamespaceSymbol`
    Members:`INamespaceMemberDeclarationNode`* NestedMembers:`INamespaceMemberDeclarationNode`*;
NamespaceMemberDeclaration <: PackageFacetChildDeclaration, NamedDeclaration, SymbolDeclaration;

// ---------- Function Declaration
// TODO better name for this or perhaps just merge AssociatedFunctionDeclaration into FunctionDeclaration
FunctionLikeDeclaration <: NamedDeclaration, InvocableDeclaration = Symbol:`FunctionSymbol` Type:`FunctionType`;
FunctionDeclaration <: PackageMemberDeclaration, FunctionLikeDeclaration;

// ---------- Type Declarations
PrimitiveTypeDeclaration <: TypeDeclaration = Name:`SpecialTypeName` Members:{TypeMemberDeclaration};
UserTypeDeclaration <: PackageMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, TypeDeclaration, NamedDeclaration
    = Name:`StandardName` GenericParameters:GenericParameterDeclaration* Symbol:`UserTypeSymbol` Members:{TypeMemberDeclaration};
ClassDeclaration <: UserTypeDeclaration = Members:{ClassMemberDeclaration};
StructDeclaration <: UserTypeDeclaration = Members:{StructMemberDeclaration};
TraitDeclaration <: UserTypeDeclaration = Members:{TraitMemberDeclaration};

// ---------- Type Declaration Parts
GenericParameterDeclaration <: TypeDeclaration, AssociatedMemberDeclaration
    = Name:`IdentifierName` Symbol:`GenericParameterTypeSymbol` Members:{TypeMemberDeclaration};

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: PackageFacetChildDeclaration, SymbolDeclaration;
ClassMemberDeclaration <: TypeMemberDeclaration;
TraitMemberDeclaration <: TypeMemberDeclaration;
StructMemberDeclaration <: TypeMemberDeclaration;
AssociatedMemberDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, SymbolDeclaration;
InstanceMemberDeclaration <: TypeMemberDeclaration;

// ---------- Member Declarations
MethodDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, NamedDeclaration, InstanceMemberDeclaration, InvocableDeclaration
    = Name:`IdentifierName` Symbol:`MethodSymbol`;
StandardMethodDeclaration <: MethodDeclaration = Arity:`int` MethodGroupType:`FunctionType`;
GetterMethodDeclaration <: MethodDeclaration;
SetterMethodDeclaration <: MethodDeclaration;
ConstructorDeclaration <: ClassMemberDeclaration, AssociatedMemberDeclaration, InvocableDeclaration
    = Name:`IdentifierName`? Symbol:`ConstructorSymbol`;
InitializerDeclaration <: StructMemberDeclaration, AssociatedMemberDeclaration, InvocableDeclaration
    = Name:`IdentifierName`? Symbol:`InitializerSymbol`;
FieldDeclaration <: NamedDeclaration, ClassMemberDeclaration, StructMemberDeclaration, InstanceMemberDeclaration = Name:`IdentifierName` Type:`DataType` Symbol:`FieldSymbol`;
AssociatedFunctionDeclaration <: AssociatedMemberDeclaration, FunctionLikeDeclaration, InvocableDeclaration;

// ---------- Can be Referenced by Type Name
TypeDeclaration <: NamedDeclaration, SymbolDeclaration
    = Symbol:`TypeSymbol` Members:{TypeMemberDeclaration};

// -------------------------------------------------------------------------------------------------
// Symbol Nodes
// -------------------------------------------------------------------------------------------------
// Implementations of declarations that are derived from symbols.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

// ---------- Packages
PackageSymbol <: PackageDeclaration = MainFacet:PackageFacetDeclaration TestingFacet:PackageFacetDeclaration;

// ---------- Facets
// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacetSymbol <: PackageFacetDeclaration = GlobalNamespace:NamespaceDeclaration;

// ---------- Namespace Declarations
NamespaceSymbol <: NamespaceDeclaration = Members:NamespaceMemberDeclaration*;

// ---------- Function Declaration
FunctionSymbol <: FunctionDeclaration;

// ---------- Type Declarations
PrimitiveTypeSymbol <: PrimitiveTypeDeclaration = Members:{TypeMemberDeclaration};
UserTypeSymbol <: UserTypeDeclaration = GenericParameters:GenericParameterDeclaration* Members:{TypeMemberDeclaration};
ClassSymbol <: ClassDeclaration = GenericParameters:GenericParameterDeclaration* Members:{ClassMemberDeclaration};
StructSymbol <: StructDeclaration = GenericParameters:GenericParameterDeclaration* Members:{StructMemberDeclaration};
TraitSymbol <: TraitDeclaration = GenericParameters:GenericParameterDeclaration* Members:{TraitMemberDeclaration};

// ---------- Type Declaration Parts
GenericParameterSymbol <: GenericParameterDeclaration = Members:{TypeMemberDeclaration};

// ---------- Member Declarations
MethodSymbol <: MethodDeclaration;
StandardMethodSymbol <: MethodSymbol, StandardMethodDeclaration;
GetterMethodSymbol <: MethodSymbol, GetterMethodDeclaration;
SetterMethodSymbol <: MethodSymbol, SetterMethodDeclaration;
ConstructorSymbol <: ConstructorDeclaration;
InitializerSymbol <: InitializerDeclaration;
FieldSymbol <: FieldDeclaration;
AssociatedFunctionSymbol <: AssociatedFunctionDeclaration;
