◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes.Model;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageNode`;

// ---------- Special Parts
BodyOrBlock <: Code;
ElseClause <: Code;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding <: Code = IsMutableBinding:`bool`;
LocalBinding: Binding;

// ---------- Packages
// Declarations and TestingDeclarations types quoted so that is is not treated as a child node
Package = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol` SymbolNode:`IPackageSymbolNode`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    SymbolNodes:`FixedDictionary<IdentifierName,IPackageSymbolNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

PackageFacet <: Child = Syntax:`IPackageSyntax` PackageName:`IdentifierName`
    PackageSymbol:`PackageSymbol` SymbolNode:`IPackageFacetSymbolNode`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Declarations:`IFixedSet<IPackageMemberDeclarationNode>`;

PackageMemberDeclaration <: NamespaceMemberDeclaration
    = Attributes:Attribute* AccessModifier:`AccessModifier` SymbolNode:`IPackageMemberSymbolNode`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax` File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingSymbolNode:`IPackageFacetSymbolNode` ContainingSymbol:`NamespaceSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespaceSymbolNode:`INamespaceSymbolNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Declarations
Declaration <: Code = Syntax:`IDeclarationSyntax` ContainingSymbolNode:`ISymbolNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`
    SymbolNode:`IDeclarationSymbolNode`;
InvocableDeclaration <: Declaration = Parameters:ConstructorOrInitializerParameter*;
ConcreteInvocableDeclaration <: InvocableDeclaration = Parameters:ConstructorOrInitializerParameter*; // Body;

// ---------- Namespace Declarations
NamespaceDeclaration <: NamespaceMemberDeclaration = Syntax:`INamespaceDeclarationSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    SymbolNode:`INamespaceSymbolNode` Symbol:`NamespaceSymbol`;
NamespaceMemberDeclaration <: Declaration = SymbolNode:`INamespaceMemberSymbolNode`;

// ---------- Function Declaration
FunctionDeclaration <: PackageMemberDeclaration = Syntax:`IFunctionDeclarationSyntax`
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    Attributes:Attribute* Name:`IdentifierName`
    SymbolNode:`IFunctionSymbolNode` Symbol:`FunctionSymbol` Parameters:NamedParameter* Return:Type?
    Type:`FunctionType`;

// ---------- Type Declarations
TypeDeclaration <: PackageMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`ITypeDeclarationSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` SymbolNode:`IUserTypeSymbolNode` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:TypeMemberDeclaration*;
ClassDeclaration <: TypeDeclaration = Syntax:`IClassDeclarationSyntax`
    Attributes:Attribute* IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName* SymbolNode:`IClassSymbolNode`
    DeclaredType:`ObjectType`
    Members:ClassMemberDeclaration*
    DefaultConstructorSymbol:`ConstructorSymbol`?;
StructDeclaration <: TypeDeclaration = Syntax:`IStructDeclarationSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`IStructSymbolNode`
    DeclaredType:`StructType`
    Members:StructMemberDeclaration*;
TraitDeclaration <: TypeDeclaration = Syntax:`ITraitDeclarationSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`ITraitSymbolNode`
    DeclaredType:`ObjectType`
    Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameter <: Code = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingSymbolNode:`IUserTypeSymbolNode` ContainingSymbol:`UserTypeSymbol`
    SymbolNode:`IGenericParameterSymbolNode` Symbol:`GenericParameterTypeSymbol`;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: Declaration = Syntax:`ITypeMemberDeclarationSyntax` AccessModifier:`AccessModifier` SymbolNode:`ITypeMemberSymbolNode`;
ClassMemberDeclaration <: TypeMemberDeclaration = Syntax:`IClassMemberDeclarationSyntax` SymbolNode:`IClassMemberSymbolNode`;
TraitMemberDeclaration <: TypeMemberDeclaration = Syntax:`ITraitMemberDeclarationSyntax` SymbolNode:`ITraitMemberSymbolNode`;
StructMemberDeclaration <: TypeMemberDeclaration = Syntax:`IStructMemberDeclarationSyntax` SymbolNode:`IStructMemberSymbolNode`;
AlwaysTypeMemberDeclaration <: TypeMemberDeclaration = ContainingSymbol:`UserTypeSymbol`;

// ---------- Member Declarations
MethodDeclaration <: AlwaysTypeMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, InvocableDeclaration
    = Syntax:`IMethodDeclarationSyntax` Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    SymbolNode:`IMethodSymbolNode` Symbol:`MethodSymbol`;
AbstractMethodDeclaration <: MethodDeclaration = Syntax:`IAbstractMethodDeclarationSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    ContainingDeclaredType:`ObjectType`;
ConcreteMethodDeclaration <: MethodDeclaration, StructMemberDeclaration, ConcreteInvocableDeclaration
    = Syntax:`IConcreteMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
StandardMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`IStandardMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
GetterMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`IGetterMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type; // Body;
SetterMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`ISetterMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
ConstructorDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, ClassMemberDeclaration
    = Syntax:`IConstructorDeclarationSyntax` Name:`IdentifierName`? SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`ConstructorSymbol`; // Body:BlockBody;
InitializerDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, StructMemberDeclaration
    = Syntax:`IInitializerDeclarationSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`InitializerSymbol`; // Body:BlockBody;
FieldDeclaration <: AlwaysTypeMemberDeclaration, ClassMemberDeclaration, StructMemberDeclaration, Binding
    = Syntax:`IFieldDeclarationSyntax` IsMutableBinding:`bool` Name:`IdentifierName` TypeNode:Type Type:`DataType`
    SymbolNode:`IFieldSymbolNode` Symbol:`FieldSymbol` Initializer:UntypedExpression?;
AssociatedFunctionDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`IAssociatedFunctionDeclarationSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type?
    SymbolNode:`IAssociatedFunctionSymbolNode` Symbol:`FunctionSymbol` Type:`FunctionType`; // Body;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:StandardTypeName ReferencedSymbol:`ConstructorSymbol`?;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax` Name:`IdentifierName`? Unused:`bool` Type:`Pseudotype`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax` Type:`DataType` ParameterType:`Parameter`;
NamedParameter <: ConstructorOrInitializerParameter = Syntax:`INamedParameterSyntax`
    IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`?
    TypeNode:Type;
SelfParameter <: Parameter = Syntax:`ISelfParameterSyntax` IsLentBinding:`bool` ContainingDeclaredType:`IDeclaredUserType`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ReferenceType` ContainingDeclaredType:`ObjectType`;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ValueType` ContainingDeclaredType:`StructType`;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` IsLentBinding:`bool` Capability:CapabilityConstraint
    ParameterType:`SelfParameter`;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax` Name:`IdentifierName`
    ContainingTypeDeclaration:`ITypeDeclarationNode` ReferencedSymbolNode:`IFieldSymbolNode`?;

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body; // = Statements:BodyStatement*;
ExpressionBody: Body; // = ResultStatement Statements:Statement*;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Type:`DataType`;
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` IsAttributeType:`bool` Name:`StandardName` ReferencedSymbolNode:`ITypeSymbolNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type SelfType:`Pseudotype`?;

// ---------- Statements
Statement <: Code;
ResultStatement: Statement <: BlockOrResult = UntypedExpression;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement <: LocalBinding = Name:`IdentifierName` Capability? Type? Initializer:UntypedExpression?;
ExpressionStatement: BodyStatement = UntypedExpression;

// ---------- Patterns
Pattern <: Code;
BindingContextPattern <: Pattern = IsMutableBinding:`bool` Pattern Type?;
OptionalOrBindingPattern <: Pattern;
BindingPattern <: OptionalOrBindingPattern, LocalBinding = Name:`IdentifierName`;
OptionalPattern <: OptionalOrBindingPattern = Pattern:OptionalOrBindingPattern;

// ---------- Expressions
UntypedExpression <: Code;
Expression <: UntypedExpression;
AssignableExpression <: Expression; // = ReferencedSymbol:`IPromise<Symbol?>`;
BlockExpression <: Expression, BlockOrResult, BodyOrBlock = Statements:Statement*;
NewObjectExpression <: Expression = Type:TypeName ConstructorName:`IdentifierName`? Arguments:UntypedExpression* ReferencedSymbol:`ConstructorSymbol?`;
UnsafeExpression <: Expression = UntypedExpression;

// ---------- Literal Expressions
LiteralExpression <: Expression;
BoolLiteralExpression <: LiteralExpression = Value:`bool` Type:`BoolConstValueType`;
IntegerLiteralExpression <: LiteralExpression = Value:`BigInteger` Type:`IntegerConstValueType`;
NoneLiteralExpression <: LiteralExpression = Type:`OptionalType`;
StringLiteralExpression <: LiteralExpression = Value:`string` Type:`DataType`;

// ---------- Operator Expressions
AssignmentExpression <: Expression = LeftOperand:AssignableExpression Operator:`AssignmentOperator` RightOperand:UntypedExpression;
BinaryOperatorExpression <: Expression = LeftOperand:UntypedExpression Operator:`BinaryOperator` RightOperand:UntypedExpression;
UnaryOperatorExpression <: Expression = Fixity:`UnaryOperatorFixity` Operator:`UnaryOperator` Operand:UntypedExpression;
IdExpression <: Expression = Referent:UntypedExpression;
ConversionExpression <: Expression = Referent:UntypedExpression Operator:`ConversionOperator` ConvertToType:Type;
PatternMatchExpression <: Expression = Referent:UntypedExpression Pattern;

// ---------- Control Flow Expressions
IfExpression <: Expression, ElseClause = Condition:UntypedExpression ThenBlock:BlockOrResult ElseClause?;
LoopExpression <: Expression = Block:BlockExpression;
WhileExpression <: Expression = Condition:UntypedExpression Block:BlockExpression;
ForeachExpression <: Expression, LocalBinding = VariableName:`IdentifierName` InExpression:UntypedExpression Type? Block:BlockExpression;
NeverTypedExpression <: Expression = Type:`NeverType`;
BreakExpression <: NeverTypedExpression = Value:UntypedExpression?;
NextExpression <: NeverTypedExpression;
ReturnExpression <: NeverTypedExpression = Value:UntypedExpression?;

// ---------- Invocation Expressions
InvocationExpression <: Expression = UntypedExpression Arguments:UntypedExpression*;

// ---------- Name Expressions
NameExpression <: UntypedExpression; // = ReferencedSymbol:`Symbol?`;
InvocableNameExpression <: NameExpression;
VariableNameExpression <: NameExpression;
StandardNameExpression <: NameExpression = Name:`StandardName`? ReferencedSymbol:`Symbol?`;
SimpleNameExpression <: NameExpression;
IdentifierNameExpression <: NameExpression, InvocableNameExpression, SimpleNameExpression, StandardNameExpression, VariableNameExpression, AssignableExpression = Name:`IdentifierName`?;
SpecialTypeNameExpression <: NameExpression, SimpleNameExpression = Name:`SpecialTypeName` ReferencedSymbol:`TypeSymbol`?;
GenericNameExpression <: NameExpression, InvocableNameExpression, StandardNameExpression = Name:`GenericName` TypeArguments:Type*;
SelfExpression <: NameExpression, VariableNameExpression, Expression = IsImplicit:`bool` Pseudotype:`Pseudotype`;
MemberAccessExpression <: NameExpression, InvocableNameExpression, AssignableExpression = Context:UntypedExpression AccessOperator:`AccessOperator` MemberName:`StandardName` TypeArguments:Type*;

// ---------- Capability Expressions
MoveExpression <: Expression = Referent:VariableNameExpression;
FreezeExpression <: Expression = Referent:VariableNameExpression;

// ---------- Async Expressions
AsyncBlockExpression <: Expression = Block:BlockExpression;
AsyncStartExpression <: Expression = Scheduled:`bool` UntypedExpression;
AwaitExpression <: Expression = UntypedExpression;
