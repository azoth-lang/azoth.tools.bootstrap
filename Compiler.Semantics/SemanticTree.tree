◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes.Model;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageNode`;

// ---------- Packages
// Declarations and TestingDeclarations types quoted so that is is not treated as a child node
Package = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol` SymbolNode:`IPackageSymbolNode`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    SymbolNodes:`FixedDictionary<IdentifierName,IPackageSymbolNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

PackageFacet <: Child = Syntax:`IPackageSyntax` PackageName:`IdentifierName`
    PackageSymbol:`PackageSymbol` SymbolNode:`IPackageFacetSymbolNode`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Declarations:`IFixedSet<IPackageMemberDeclarationNode>`;

PackageMemberDeclaration <: NamespaceMemberDeclaration = SymbolNode:`IPackageMemberSymbolNode`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax` File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingSymbolNode:`IPackageFacetSymbolNode` ContainingSymbol:`NamespaceSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespaceSymbolNode:`INamespaceSymbolNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Declarations
Declaration <: Code = Syntax:`IDeclarationSyntax` ContainingSymbolNode:`ISymbolNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope` SymbolNode:`IDeclarationSymbolNode`;

// ---------- Namespaces
NamespaceDeclaration <: NamespaceMemberDeclaration = Syntax:`INamespaceDeclarationSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    SymbolNode:`INamespaceSymbolNode` Symbol:`NamespaceSymbol`;
NamespaceMemberDeclaration <: Declaration = SymbolNode:`INamespaceMemberSymbolNode`;

// ---------- Type Declarations
TypeDeclaration <: PackageMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`ITypeDeclarationSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` SymbolNode:`IUserTypeSymbolNode` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:TypeMemberDeclaration*;
ClassDeclaration <: TypeDeclaration = Syntax:`IClassDeclarationSyntax` IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName* SymbolNode:`IClassSymbolNode`
    DeclaredType:`ObjectType`
    Members:ClassMemberDeclaration*;
StructDeclaration <: TypeDeclaration = Syntax:`IStructDeclarationSyntax` GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`IStructSymbolNode`
    DeclaredType:`StructType`
    Members:StructMemberDeclaration*;
TraitDeclaration <: TypeDeclaration = Syntax:`ITraitDeclarationSyntax` GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`ITraitSymbolNode`
    DeclaredType:`ObjectType`
    Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameter <: Code = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingSymbolNode:`IUserTypeSymbolNode` ContainingSymbol:`UserTypeSymbol`
    SymbolNode:`IGenericParameterSymbolNode` Symbol:`GenericParameterTypeSymbol`;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: Declaration = Syntax:`ITypeMemberDeclarationSyntax`;
ClassMemberDeclaration <: TypeMemberDeclaration = Syntax:`IClassMemberDeclarationSyntax`;
TraitMemberDeclaration <: TypeMemberDeclaration = Syntax:`ITraitMemberDeclarationSyntax`;
StructMemberDeclaration <: TypeMemberDeclaration = Syntax:`IStructMemberDeclarationSyntax`;

// ---------- Invocable Declarations
FunctionDeclaration <: PackageMemberDeclaration = Syntax:`IFunctionDeclarationSyntax`
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol` Name:`IdentifierName`
    SymbolNode:`IFunctionSymbolNode` Symbol:`FunctionSymbol` Parameters:NamedParameter* Return:Type?
    Type:`FunctionType`;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax` Name:`IdentifierName`? Type:`Parameter` Unused:`bool`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax`;
NamedParameter: ConstructorOrInitializerParameter = Syntax:`INamedParameterSyntax` IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`? TypeNode:Type;
SelfParameter: Parameter = IsLentBinding:`bool`;
ConstructorSelfParameter: SelfParameter = IsLentBinding:`bool` Capability;
InitializerSelfParameter: SelfParameter = IsLentBinding:`bool` Capability;
MethodSelfParameter: SelfParameter = IsLentBinding:`bool` Capability:CapabilityConstraint;
FieldParameter: ConstructorOrInitializerParameter = Name:`IdentifierName`;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Type:`DataType`;
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` Name:`StandardName` ReferencedSymbolNode:`ITypeSymbolNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type;
