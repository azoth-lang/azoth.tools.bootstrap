◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes.Model;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageNode`;

// ---------- Special Parts
BodyOrBlock;

// ---------- Packages
// Declarations and TestingDeclarations types quoted so that is is not treated as a child node
Package = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol` SymbolNode:`IPackageSymbolNode`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    SymbolNodes:`FixedDictionary<IdentifierName,IPackageSymbolNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

PackageFacet <: Child = Syntax:`IPackageSyntax` PackageName:`IdentifierName`
    PackageSymbol:`PackageSymbol` SymbolNode:`IPackageFacetSymbolNode`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Declarations:`IFixedSet<IPackageMemberDeclarationNode>`;

PackageMemberDeclaration <: NamespaceMemberDeclaration
    = Attributes:Attribute* SymbolNode:`IPackageMemberSymbolNode`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax` File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingSymbolNode:`IPackageFacetSymbolNode` ContainingSymbol:`NamespaceSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespaceSymbolNode:`INamespaceSymbolNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Declarations
Declaration <: Code = Syntax:`IDeclarationSyntax` ContainingSymbolNode:`ISymbolNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`
    SymbolNode:`IDeclarationSymbolNode`;
InvocableDeclaration <: Declaration = Parameters:ConstructorOrInitializerParameter*;
ConcreteInvocableDeclaration <: InvocableDeclaration = Parameters:ConstructorOrInitializerParameter*; // Body;

// ---------- Namespace Declarations
NamespaceDeclaration <: NamespaceMemberDeclaration = Syntax:`INamespaceDeclarationSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    SymbolNode:`INamespaceSymbolNode` Symbol:`NamespaceSymbol`;
NamespaceMemberDeclaration <: Declaration = SymbolNode:`INamespaceMemberSymbolNode`;

// ---------- Function Declaration
FunctionDeclaration <: PackageMemberDeclaration = Syntax:`IFunctionDeclarationSyntax`
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    Attributes:Attribute* Name:`IdentifierName`
    SymbolNode:`IFunctionSymbolNode` Symbol:`FunctionSymbol` Parameters:NamedParameter* Return:Type?
    Type:`FunctionType`;

// ---------- Type Declarations
TypeDeclaration <: PackageMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`ITypeDeclarationSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` SymbolNode:`IUserTypeSymbolNode` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:TypeMemberDeclaration*;
ClassDeclaration <: TypeDeclaration = Syntax:`IClassDeclarationSyntax`
    Attributes:Attribute* IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName* SymbolNode:`IClassSymbolNode`
    DeclaredType:`ObjectType`
    Members:ClassMemberDeclaration*
    DefaultConstructorSymbol:`ConstructorSymbol`?;
StructDeclaration <: TypeDeclaration = Syntax:`IStructDeclarationSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`IStructSymbolNode`
    DeclaredType:`StructType`
    Members:StructMemberDeclaration*;
TraitDeclaration <: TypeDeclaration = Syntax:`ITraitDeclarationSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`ITraitSymbolNode`
    DeclaredType:`ObjectType`
    Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameter <: Code = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingSymbolNode:`IUserTypeSymbolNode` ContainingSymbol:`UserTypeSymbol`
    SymbolNode:`IGenericParameterSymbolNode` Symbol:`GenericParameterTypeSymbol`;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: Declaration = Syntax:`ITypeMemberDeclarationSyntax` SymbolNode:`ITypeMemberSymbolNode`;
ClassMemberDeclaration <: TypeMemberDeclaration = Syntax:`IClassMemberDeclarationSyntax` SymbolNode:`IClassMemberSymbolNode`;
TraitMemberDeclaration <: TypeMemberDeclaration = Syntax:`ITraitMemberDeclarationSyntax` SymbolNode:`ITraitMemberSymbolNode`;
StructMemberDeclaration <: TypeMemberDeclaration = Syntax:`IStructMemberDeclarationSyntax` SymbolNode:`IStructMemberSymbolNode`;
AlwaysTypeMemberDeclaration <: TypeMemberDeclaration = ContainingSymbol:`UserTypeSymbol`;

// ---------- Member Declarations
MethodDeclaration <: AlwaysTypeMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, InvocableDeclaration
    = Syntax:`IMethodDeclarationSyntax` Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    SymbolNode:`IMethodSymbolNode` Symbol:`MethodSymbol`;
AbstractMethodDeclaration <: MethodDeclaration = Syntax:`IAbstractMethodDeclarationSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    ContainingDeclaredType:`ObjectType`;
ConcreteMethodDeclaration <: MethodDeclaration, StructMemberDeclaration, ConcreteInvocableDeclaration
    = Syntax:`IConcreteMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
StandardMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`IStandardMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
GetterMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`IGetterMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type; // Body;
SetterMethodDeclaration <: ConcreteMethodDeclaration = Syntax:`ISetterMethodDeclarationSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?; // Body;
ConstructorDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, ClassMemberDeclaration
    = Syntax:`IConstructorDeclarationSyntax` Name:`IdentifierName`? SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`ConstructorSymbol`; // Body:BlockBody;
InitializerDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, StructMemberDeclaration
    = Syntax:`IInitializerDeclarationSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`InitializerSymbol`; // Body:BlockBody;
FieldDeclaration <: AlwaysTypeMemberDeclaration, ClassMemberDeclaration, StructMemberDeclaration
    = Syntax:`IFieldDeclarationSyntax` IsMutableBinding:`bool` Name:`IdentifierName` TypeNode:Type Type:`DataType`
    SymbolNode:`IFieldSymbolNode` Symbol:`FieldSymbol`;
AssociatedFunctionDeclaration <: ConcreteInvocableDeclaration, AlwaysTypeMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`IAssociatedFunctionDeclarationSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type?
    SymbolNode:`IAssociatedFunctionSymbolNode` Symbol:`FunctionSymbol` Type:`FunctionType`; // Body;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:StandardTypeName ReferencedSymbol:`ConstructorSymbol`?;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax` Name:`IdentifierName`? Unused:`bool` Type:`Pseudotype`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax` Type:`DataType` ParameterType:`Parameter`;
NamedParameter <: ConstructorOrInitializerParameter = Syntax:`INamedParameterSyntax`
    IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`?
    TypeNode:Type;
SelfParameter <: Parameter = Syntax:`ISelfParameterSyntax` IsLentBinding:`bool` ContainingDeclaredType:`IDeclaredUserType`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ReferenceType` ContainingDeclaredType:`ObjectType`;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ValueType` ContainingDeclaredType:`StructType`;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` IsLentBinding:`bool` Capability:CapabilityConstraint
    ParameterType:`SelfParameter`;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax` Name:`IdentifierName`
    ContainingTypeDeclaration:`ITypeDeclarationNode` ReferencedSymbolNode:`IFieldSymbolNode`?;

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body;
ExpressionBody: Body;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Type:`DataType`;
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` IsAttributeType:`bool` Name:`StandardName` ReferencedSymbolNode:`ITypeSymbolNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type SelfType:`Pseudotype`?;
