◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.LexicalScopes.Model;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Declared;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Parameters;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`?;
// Parent and Package types quoted so that is is not treated as a child node
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode` Package:`IPackageNode`;

// ---------- Special Parts
BodyOrBlock <: Code;
ElseClause <: Code;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding <: Code = IsMutableBinding:`bool`;
LocalBinding: Binding;

// ---------- Packages
Package = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol` SymbolNode:`IPackageSymbolNode`
    References:{PackageReference} IntrinsicsReference:`IPackageReferenceNode`
    SymbolNodes:`FixedDictionary<IdentifierName,IPackageSymbolNode>`
    MainFacet:PackageFacet TestingFacet:PackageFacet Diagnostics:`Diagnostic`*;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`? SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` PackageSymbols:`IPackageSymbols` IsTrusted:`bool`;

PackageFacet <: Child = Syntax:`IPackageSyntax` PackageName:`IdentifierName`
    PackageSymbol:`PackageSymbol` SymbolNode:`IPackageFacetSymbolNode`
    PackageNameScope:`PackageNameScope`
    CompilationUnits:{CompilationUnit} Definitions:`IFixedSet<IPackageMemberDefinitionNode>`;

PackageMemberDefinition <: NamespaceMemberDefinition
    = Attributes:Attribute* AccessModifier:`AccessModifier` SymbolNode:`IPackageMemberSymbolNode`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax` File:`CodeFile`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ContainingSymbolNode:`IPackageFacetSymbolNode` ContainingSymbol:`NamespaceSymbol`
    ImplicitNamespaceName:`NamespaceName` ImplicitNamespaceSymbolNode:`INamespaceSymbolNode` ImplicitNamespaceSymbol:`NamespaceSymbol`
    UsingDirectives:UsingDirective* Definitions:NamespaceMemberDefinition*
    ContainingLexicalScope:`NamespaceScope` LexicalScope:`LexicalScope`
    Diagnostics:`Diagnostic`*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Definitions
Definition <: Code = Syntax:`IDefinitionSyntax` ContainingSymbolNode:`ISymbolNode` ContainingSymbol:`Symbol`
    ContainingLexicalScope:`LexicalScope` LexicalScope:`LexicalScope`
    SymbolNode:`IDeclarationSymbolNode`;
InvocableDefinition <: Definition = Parameters:ConstructorOrInitializerParameter*;
ConcreteInvocableDefinition <: InvocableDefinition = Parameters:ConstructorOrInitializerParameter* Body;

// ---------- Namespace Definitions
NamespaceDefinition <: NamespaceMemberDefinition = Syntax:`INamespaceDefinitionSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Definitions:NamespaceMemberDefinition*
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    SymbolNode:`INamespaceSymbolNode` Symbol:`NamespaceSymbol`;
NamespaceMemberDefinition <: Definition = SymbolNode:`INamespaceMemberSymbolNode`;

// ---------- Function Definition
FunctionDefinition <: PackageMemberDefinition = Syntax:`IFunctionDefinitionSyntax`
    ContainingSymbolNode:`INamespaceSymbolNode` ContainingSymbol:`NamespaceSymbol`
    Attributes:Attribute* Name:`IdentifierName`
    SymbolNode:`IFunctionSymbolNode` Symbol:`FunctionSymbol` Parameters:NamedParameter* Return:Type? Body
    Type:`FunctionType`;

// ---------- Type Definitions
TypeDefinition <: PackageMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition
    = Syntax:`ITypeDefinitionSyntax` IsConst:`bool` Name:`StandardName`
    DeclaredType:`IDeclaredUserType` SymbolNode:`IUserTypeSymbolNode` Symbol:`UserTypeSymbol`
    GenericParameters:GenericParameter* SupertypesLexicalScope:`LexicalScope`
    SupertypeNames:StandardTypeName* Supertypes:`CompilerResult<IFixedSet<BareReferenceType>>`
    Members:TypeMemberDefinition*;
ClassDefinition <: TypeDefinition = Syntax:`IClassDefinitionSyntax`
    Attributes:Attribute* IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName* SymbolNode:`IClassSymbolNode`
    DeclaredType:`ObjectType`
    Members:ClassMemberDefinition*
    DefaultConstructorSymbol:`ConstructorSymbol`?;
StructDefinition <: TypeDefinition = Syntax:`IStructDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`IStructSymbolNode`
    DeclaredType:`StructType`
    Members:StructMemberDefinition*;
TraitDefinition <: TypeDefinition = Syntax:`ITraitDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:StandardTypeName* SymbolNode:`ITraitSymbolNode`
    DeclaredType:`ObjectType`
    Members:TraitMemberDefinition*;

// ---------- Type Definition Parts
GenericParameter <: Code = Syntax:`IGenericParameterSyntax`
    Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`
    Parameter:`GenericParameter` ContainingDeclaredType:`IDeclaredUserType` DeclaredType:`GenericParameterType`
    ContainingSymbolNode:`IUserTypeSymbolNode` ContainingSymbol:`UserTypeSymbol`
    SymbolNode:`IGenericParameterSymbolNode` Symbol:`GenericParameterTypeSymbol`;

// ---------- Type Member Definitions (i.e. declarations that can be contained in a type)
TypeMemberDefinition <: Definition = Syntax:`ITypeMemberDefinitionSyntax` AccessModifier:`AccessModifier` SymbolNode:`ITypeMemberSymbolNode`;
ClassMemberDefinition <: TypeMemberDefinition = Syntax:`IClassMemberDefinitionSyntax` SymbolNode:`IClassMemberSymbolNode`;
TraitMemberDefinition <: TypeMemberDefinition = Syntax:`ITraitMemberDefinitionSyntax` SymbolNode:`ITraitMemberSymbolNode`;
StructMemberDefinition <: TypeMemberDefinition = Syntax:`IStructMemberDefinitionSyntax` SymbolNode:`IStructMemberSymbolNode`;
AlwaysTypeMemberDefinition <: TypeMemberDefinition = ContainingSymbol:`UserTypeSymbol`;

// ---------- Member Definitions
MethodDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, InvocableDefinition
    = Syntax:`IMethodDefinitionSyntax` Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    SymbolNode:`IMethodSymbolNode` Symbol:`MethodSymbol`;
AbstractMethodDefinition <: MethodDefinition = Syntax:`IAbstractMethodDefinitionSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type?
    ContainingDeclaredType:`ObjectType`;
ConcreteMethodDefinition <: MethodDefinition, StructMemberDefinition, ConcreteInvocableDefinition
    = Syntax:`IConcreteMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
StandardMethodDefinition <: ConcreteMethodDefinition = Syntax:`IStandardMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
GetterMethodDefinition <: ConcreteMethodDefinition = Syntax:`IGetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type Body;
SetterMethodDefinition <: ConcreteMethodDefinition = Syntax:`ISetterMethodDefinitionSyntax` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return:Type? Body;
ConstructorDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition
    = Syntax:`IConstructorDefinitionSyntax` Name:`IdentifierName`? SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`ConstructorSymbol` Body:BlockBody;
InitializerDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, StructMemberDefinition
    = Syntax:`IInitializerDefinitionSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter*
    Symbol:`InitializerSymbol` Body:BlockBody;
FieldDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition, StructMemberDefinition, Binding
    = Syntax:`IFieldDefinitionSyntax` IsMutableBinding:`bool` Name:`IdentifierName` TypeNode:Type Type:`DataType`
    SymbolNode:`IFieldSymbolNode` Symbol:`FieldSymbol` Initializer:UntypedExpression?;
AssociatedFunctionDefinition <: ConcreteInvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition
    = Syntax:`IAssociatedFunctionDefinitionSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type?
    SymbolNode:`IAssociatedFunctionSymbolNode` Symbol:`FunctionSymbol` Type:`FunctionType` Body;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:StandardTypeName ReferencedSymbol:`ConstructorSymbol`?;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax` Name:`IdentifierName`? Unused:`bool` Type:`Pseudotype`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax` Type:`DataType` ParameterType:`Parameter`;
NamedParameter <: ConstructorOrInitializerParameter = Syntax:`INamedParameterSyntax`
    IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`int`?
    TypeNode:Type;
SelfParameter <: Parameter = Syntax:`ISelfParameterSyntax` IsLentBinding:`bool` ContainingDeclaredType:`IDeclaredUserType`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ReferenceType` ContainingDeclaredType:`ObjectType`;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` IsLentBinding:`bool` Capability Type:`ValueType` ContainingDeclaredType:`StructType`;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` IsLentBinding:`bool` Capability:CapabilityConstraint
    ParameterType:`SelfParameter`;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax` Name:`IdentifierName`
    ContainingTypeDefinition:`ITypeDefinitionNode` ReferencedSymbolNode:`IFieldSymbolNode`?;

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body = Syntax:`IBlockBodySyntax` Statements:BodyStatement*;
ExpressionBody: Body = Syntax:`IExpressionBodySyntax` ResultStatement;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax` Type:`DataType`;
TypeName <: Type = Syntax:`ITypeNameSyntax` Name:`TypeName` ContainingLexicalScope:`LexicalScope`
    ReferencedSymbol:`TypeSymbol`? BareType:`BareType`?;
StandardTypeName <: TypeName = Syntax:`IStandardTypeNameSyntax` IsAttributeType:`bool` Name:`StandardName` ReferencedSymbolNode:`ITypeSymbolNode`?;
SimpleTypeName <: TypeName = Syntax:`ISimpleTypeNameSyntax`;
IdentifierTypeName <: StandardTypeName, SimpleTypeName = Syntax:`IIdentifierTypeNameSyntax` Name:`IdentifierName`;
SpecialTypeName <: SimpleTypeName = Syntax:`ISpecialTypeNameSyntax` Name:`SpecialTypeName`
    ReferencedSymbol:`TypeSymbol`;
GenericTypeName <: StandardTypeName = Syntax:`IGenericTypeNameSyntax` Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedTypeNameSyntax` Context:TypeName QualifiedName:StandardTypeName;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` IsLent:`bool` Referent:Type Parameter:`Parameter`;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type SelfType:`Pseudotype`?;

// ---------- Statements
Statement <: Code = Syntax:`IStatementSyntax`;
ResultStatement: Statement <: BlockOrResult = Syntax:`IResultStatementSyntax` Expression:UntypedExpression;
BodyStatement: Statement = Syntax:`IBodyStatementSyntax`;
VariableDeclarationStatement: BodyStatement <: LocalBinding = Syntax:`IVariableDeclarationStatementSyntax`
    Name:`IdentifierName` Capability? Type? Initializer:UntypedExpression?;
ExpressionStatement: BodyStatement = Syntax:`IExpressionStatementSyntax` Expression:UntypedExpression;

// ---------- Patterns
Pattern <: Code = Syntax:`IPatternSyntax`;
BindingContextPattern <: Pattern = Syntax:`IBindingContextPatternSyntax` IsMutableBinding:`bool` Pattern Type?;
OptionalOrBindingPattern <: Pattern = Syntax:`IOptionalOrBindingPatternSyntax`;
BindingPattern <: OptionalOrBindingPattern, LocalBinding = Syntax:`IBindingPatternSyntax` Name:`IdentifierName`;
OptionalPattern <: OptionalOrBindingPattern = Syntax:`IOptionalPatternSyntax` Pattern:OptionalOrBindingPattern;

// ---------- Expressions
UntypedExpression <: Code = Syntax:`IExpressionSyntax`;
Expression <: UntypedExpression = Syntax:`ITypedExpressionSyntax`;
AssignableExpression <: Expression = Syntax:`IAssignableExpressionSyntax`; // ReferencedSymbol:`IPromise<Symbol?>`;
BlockExpression <: Expression, BlockOrResult, BodyOrBlock = Syntax:`IBlockExpressionSyntax` Statements:Statement*;
NewObjectExpression <: Expression = Syntax:`INewObjectExpressionSyntax` Type:TypeName ConstructorName:`IdentifierName`? Arguments:UntypedExpression* ReferencedSymbol:`ConstructorSymbol?`;
UnsafeExpression <: Expression = Syntax:`IUnsafeExpressionSyntax` Expression:UntypedExpression;
NeverTypedExpression <: Expression = Syntax:`INeverTypedExpressionSyntax` Type:`NeverType`;

// ---------- Literal Expressions
LiteralExpression <: Expression = Syntax:`ILiteralExpressionSyntax`;
BoolLiteralExpression <: LiteralExpression = Syntax:`IBoolLiteralExpressionSyntax` Value:`bool` Type:`BoolConstValueType`;
IntegerLiteralExpression <: LiteralExpression = Syntax:`IIntegerLiteralExpressionSyntax` Value:`BigInteger` Type:`IntegerConstValueType`;
NoneLiteralExpression <: LiteralExpression = Syntax:`INoneLiteralExpressionSyntax` Type:`OptionalType`;
StringLiteralExpression <: LiteralExpression = Syntax:`IStringLiteralExpressionSyntax`
    Value:`string` Type:`DataType` ContainingLexicalScope:`LexicalScope`;

// ---------- Operator Expressions
AssignmentExpression <: Expression = Syntax:`IAssignmentExpressionSyntax` LeftOperand:AssignableExpression Operator:`AssignmentOperator` RightOperand:UntypedExpression;
BinaryOperatorExpression <: Expression = Syntax:`IBinaryOperatorExpressionSyntax` LeftOperand:UntypedExpression Operator:`BinaryOperator` RightOperand:UntypedExpression;
UnaryOperatorExpression <: Expression = Syntax:`IUnaryOperatorExpressionSyntax` Fixity:`UnaryOperatorFixity` Operator:`UnaryOperator` Operand:UntypedExpression;
IdExpression <: Expression = Syntax:`IIdExpressionSyntax` Referent:UntypedExpression;
ConversionExpression <: Expression = Syntax:`IConversionExpressionSyntax` Referent:UntypedExpression Operator:`ConversionOperator` ConvertToType:Type;
PatternMatchExpression <: Expression = Syntax:`IPatternMatchExpressionSyntax` Referent:UntypedExpression Pattern;

// ---------- Control Flow Expressions
IfExpression <: Expression, ElseClause = Syntax:`IIfExpressionSyntax` Condition:UntypedExpression ThenBlock:BlockOrResult ElseClause?;
LoopExpression <: Expression = Syntax:`ILoopExpressionSyntax` Block:BlockExpression;
WhileExpression <: Expression = Syntax:`IWhileExpressionSyntax` Condition:UntypedExpression Block:BlockExpression;
ForeachExpression <: Expression, LocalBinding = Syntax:`IForeachExpressionSyntax` VariableName:`IdentifierName` InExpression:UntypedExpression Type? Block:BlockExpression;
BreakExpression <: NeverTypedExpression = Syntax:`IBreakExpressionSyntax` Value:UntypedExpression?;
NextExpression <: NeverTypedExpression = Syntax:`INextExpressionSyntax`;
ReturnExpression <: NeverTypedExpression = Syntax:`IReturnExpressionSyntax` Value:UntypedExpression?;

// ---------- Invocation Expressions
InvocationExpression <: Expression = Syntax:`IInvocationExpressionSyntax` Expression:UntypedExpression Arguments:UntypedExpression*;

// ---------- Name Expressions
NameExpression <: UntypedExpression = Syntax:`INameExpressionSyntax`;
InvocableNameExpression <: NameExpression = Syntax:`IInvocableNameExpressionSyntax`;
VariableNameExpression <: NameExpression = Syntax:`IVariableNameExpressionSyntax`;
StandardNameExpression <: NameExpression = Syntax:`IStandardNameExpressionSyntax` Name:`StandardName`? ReferencedSymbol:`Symbol?`;
SimpleNameExpression <: NameExpression = Syntax:`ISimpleNameExpressionSyntax`;
IdentifierNameExpression <: NameExpression, InvocableNameExpression, SimpleNameExpression, StandardNameExpression, VariableNameExpression, AssignableExpression
    = Syntax:`IIdentifierNameExpressionSyntax` Name:`IdentifierName`?;
SpecialTypeNameExpression <: NameExpression, SimpleNameExpression
    = Syntax:`ISpecialTypeNameExpressionSyntax` Name:`SpecialTypeName` ReferencedSymbol:`TypeSymbol`?;
GenericNameExpression <: NameExpression, InvocableNameExpression, StandardNameExpression
    = Syntax:`IGenericNameExpressionSyntax` Name:`GenericName` TypeArguments:Type*;
MemberAccessExpression <: NameExpression, InvocableNameExpression, AssignableExpression
    = Syntax:`IMemberAccessExpressionSyntax` Context:UntypedExpression AccessOperator:`AccessOperator` MemberName:`StandardName` TypeArguments:Type*;
SelfExpression <: NameExpression, VariableNameExpression, Expression
    = Syntax:`ISelfExpressionSyntax` IsImplicit:`bool` Pseudotype:`Pseudotype`;
MissingNameExpression <: NameExpression, VariableNameExpression, AssignableExpression, Expression
    = Syntax:`IIdentifierNameExpressionSyntax`;

// ---------- Capability Expressions
MoveExpression <: Expression = Syntax:`IMoveExpressionSyntax` Referent:VariableNameExpression;
FreezeExpression <: Expression = Syntax:`IFreezeExpressionSyntax` Referent:VariableNameExpression;

// ---------- Async Expressions
AsyncBlockExpression <: Expression = Syntax:`IAsyncBlockExpressionSyntax` Block:BlockExpression;
AsyncStartExpression <: Expression = Syntax:`IAsyncStartExpressionSyntax` Scheduled:`bool` Expression:UntypedExpression;
AwaitExpression <: Expression = Syntax:`IAwaitExpressionSyntax` Expression:UntypedExpression;
