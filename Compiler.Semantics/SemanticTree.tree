◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root Semantic;
◊prefix I;
◊suffix Node;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.CST;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Framework;

Semantic = Syntax:`ISyntax`;
Child <: `IChild<ISemanticNode>` = Parent:`ISemanticNode`; // Parent type quoted so that is is not treated as a child node

// ---------- Packages
Package = Syntax:`IPackageSyntax` Name:`IdentifierName` Symbol:`PackageSymbol` SymbolNode:`IPackageSymbolNode`
    References:{PackageReference} SymbolNodes:`FixedDictionary<IdentifierName,IPackageSymbolNode>`
    CompilationUnits:{CompilationUnit} TestingCompilationUnits:{CompilationUnit};

PackageReference <: Child = Syntax:`IPackageReferenceSyntax` SymbolNode:`IPackageSymbolNode`
    AliasOrName:`IdentifierName` Package:`IPackageSymbols` IsTrusted:`bool`;

// ---------- Code Files
Code <: Child = Syntax:`IConcreteSyntax`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax` File:`CodeFile` ImplicitNamespaceName:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*;

UsingDirective <: Code = Syntax:`IUsingDirectiveSyntax` Name:`NamespaceName`;

// ---------- Declarations
Declaration <: Code = Syntax:`IDeclarationSyntax` ContainingSymbol:`Symbol`;

// ---------- Namespaces
NamespaceDeclaration <: NamespaceMemberDeclaration = Syntax:`INamespaceDeclarationSyntax`
    IsGlobalQualified:`bool` DeclaredNames:`NamespaceName`
    UsingDirectives:UsingDirective* Declarations:NamespaceMemberDeclaration*
    ContainingSymbol:`NamespaceSymbol` Symbol:`NamespaceSymbol`;
NamespaceMemberDeclaration <: Declaration;

// ---------- Type Declarations
TypeDeclaration <: NamespaceMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration
    = Syntax:`ITypeDeclarationSyntax` GenericParameters:GenericParameter* SupertypeNames:SupertypeName* Members:TypeMemberDeclaration*;
ClassDeclaration <: TypeDeclaration = Syntax:`IClassDeclarationSyntax` IsAbstract:`bool` GenericParameters:GenericParameter*
    BaseTypeName:SupertypeName? SupertypeNames:SupertypeName* Members:ClassMemberDeclaration*;
StructDeclaration <: TypeDeclaration = Syntax:`IStructDeclarationSyntax` GenericParameters:GenericParameter*
    SupertypeNames:SupertypeName* Members:StructMemberDeclaration*;
TraitDeclaration <: TypeDeclaration = Syntax:`ITraitDeclarationSyntax` GenericParameters:GenericParameter*
    SupertypeNames:SupertypeName* Members:TraitMemberDeclaration*;

// ---------- Type Declaration Parts
GenericParameter <: Code = Syntax:`IGenericParameterSyntax` Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance`;
// TODO don't have a special type for this
SupertypeName <: Code = Syntax:`ISupertypeNameSyntax` Name:`TypeName`;// TypeArguments:Type*;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: Declaration = Syntax:`ITypeMemberDeclarationSyntax`;
ClassMemberDeclaration <: TypeMemberDeclaration = Syntax:`IClassMemberDeclarationSyntax`;
TraitMemberDeclaration <: TypeMemberDeclaration = Syntax:`ITraitMemberDeclarationSyntax`;
StructMemberDeclaration <: TypeMemberDeclaration = Syntax:`IStructMemberDeclarationSyntax`;

// ---------- Invocable Declarations
FunctionDeclaration <: NamespaceMemberDeclaration = Syntax:`IFunctionDeclarationSyntax`
    ContainingSymbol:`NamespaceSymbol`;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax` Constraint:`Compiler.Types.Capabilities.ICapabilityConstraint`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax` Constraint:`CapabilitySet`;
// TODO have a way to make Capability hide Constraint
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax` Capability:`Capability` Constraint:`Capability`;
