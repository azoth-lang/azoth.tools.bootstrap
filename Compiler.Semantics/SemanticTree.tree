◊namespace Azoth.Tools.Bootstrap.Compiler.Semantics;
◊root-supertype Semantic;
◊prefix I;
◊suffix Node;
◊class-suffix Node;
◊using System.Collections.Generic;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Attributes;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Code;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.ControlFlow;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.DataFlow;
◊using Azoth.Tools.Bootstrap.Compiler.Semantics.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols.Trees;
◊using Azoth.Tools.Bootstrap.Compiler.Syntax;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Plain;
◊using Azoth.Tools.Bootstrap.Framework;

// ---------- Parent
Semantic <: `ITreeNode` = Syntax:`ISyntax`?;
Child <: `IChildTreeNode<ISemanticNode>`;

// ---------- Special Parts
BodyOrBlock <: Code;
ElseClause <: Code, ControlFlow = Syntax:`ICodeSyntax`;
BlockOrResult <: ElseClause;

// ---------- Bindings
Binding <: Code, BindingDeclaration;
NamedBinding <: Binding, NamedBindingDeclaration;
LocalBinding <: NamedBinding = Syntax:`ILocalBindingSyntax`;
VariableBinding <: LocalBinding, DataFlow;

// ---------- Packages
Package <: PackageDeclaration = Syntax:`IPackageSyntax` References:{PackageReference}
    MainFacet:PackageFacet TestingFacet:PackageFacet;

PackageReference <: Child = Syntax:`IPackageReferenceSyntax`?;
StandardPackageReference <: PackageReference = Syntax:`IPackageReferenceSyntax`;
IntrinsicsPackageReference <: PackageReference;

// ---------- Facets
PackageFacet <: PackageFacetDeclaration = Syntax:`IPackageSyntax` CompilationUnits:{CompilationUnit};

FacetMemberDefinition <: NamespaceBlockMemberDefinition, NamespaceMemberDefinition
    = Attributes:Attribute*;

// ---------- Code Files
Code <: Child = Syntax:`ICodeSyntax`;

CompilationUnit <: Code = Syntax:`ICompilationUnitSyntax`
    ImportDirectives:ImportDirective* Definitions:NamespaceBlockMemberDefinition*;

ImportDirective <: Code = Syntax:`IImportDirectiveSyntax`;

// ---------- Definitions
Definition <: PackageFacetChildDeclaration = Syntax:`IDefinitionSyntax`?;
ExecutableDefinition <: Definition, SymbolDeclaration = /Entry/ /Exit/;
InvocableDefinition <: ExecutableDefinition, InvocableDeclaration
    = Parameters:ConstructorOrInitializerParameter* /Entry/ Body? /Exit/;
ConcreteFunctionInvocableDefinition <: Code, InvocableDefinition, FunctionInvocableDeclaration
    = Syntax:`IInvocableDefinitionSyntax` Name:`IdentifierName` Parameters:NamedParameter* Return:Type? Body;

// ---------- Namespace Definitions
NamespaceBlockDefinition <: NamespaceBlockMemberDefinition = Syntax:`INamespaceBlockDefinitionSyntax`
    ImportDirectives:ImportDirective* Members:NamespaceBlockMemberDefinition*;
NamespaceBlockMemberDefinition <: Definition;
NamespaceDefinition <: NamespaceMemberDefinition, NamespaceDeclaration
    = Symbol:`NamespaceSymbol` MemberNamespaces:NamespaceDefinition* PackageMembers:`IFacetMemberDefinitionNode`*;
NamespaceMemberDefinition <: NamespaceMemberDeclaration;

// ---------- Function Definition
FunctionDefinition <: FacetMemberDefinition, FunctionDeclaration, ConcreteFunctionInvocableDefinition
    = Syntax:`IFunctionDefinitionSyntax` Attributes:Attribute* /Parameters/ /Return/ /Entry/ Body /Exit/;

// ---------- Type Definitions
TypeDefinition <: Code, FacetMemberDefinition, AssociatedMemberDefinition, UserTypeDeclaration
    = Syntax:`ITypeDefinitionSyntax`
    GenericParameters:GenericParameter*
    SupertypeNames:OrdinaryTypeName*;
ClassDefinition <: Code, TypeDefinition, ClassDeclaration = Syntax:`IClassDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    BaseTypeName:OrdinaryTypeName? SupertypeNames:OrdinaryTypeName*
    SourceMembers:ClassMemberDefinition*;
StructDefinition <: Code, TypeDefinition, StructDeclaration = Syntax:`IStructDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:OrdinaryTypeName*
    SourceMembers:StructMemberDefinition*;
TraitDefinition <: Code, TypeDefinition, TraitDeclaration = Syntax:`ITraitDefinitionSyntax`
    Attributes:Attribute* GenericParameters:GenericParameter*
    SupertypeNames:OrdinaryTypeName*
    Members:{TraitMemberDefinition};

// ---------- Type Definition Parts
GenericParameter <: Code, GenericParameterDeclaration
    = Syntax:`IGenericParameterSyntax` Constraint:CapabilityConstraint;
ImplicitSelfDefinition <: ImplicitSelfDeclaration;

// ---------- Type Member Definitions (i.e. definitions that can be contained in a type)
TypeMemberDefinition <: Definition, TypeMemberDeclaration = Syntax:`ITypeMemberDefinitionSyntax`?;
ClassMemberDefinition <: TypeMemberDefinition, ClassMemberDeclaration;
TraitMemberDefinition <: TypeMemberDefinition, TraitMemberDeclaration;
StructMemberDefinition <: TypeMemberDefinition, StructMemberDeclaration;
AlwaysTypeMemberDefinition <: TypeMemberDefinition, AlwaysTypeMemberDeclaration;
AssociatedMemberDefinition <: ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, NamedDeclaration
    = Name:`OrdinaryName`;

// ---------- Member Definitions
MethodDefinition <: Code, AlwaysTypeMemberDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, InvocableDefinition, MethodDeclaration
    = Syntax:`IMethodDefinitionSyntax`
    SelfParameter:MethodSelfParameter Parameters:NamedParameter* Body? Return:Type?;
// TODO getters and setters can be abstract too
AbstractMethodDefinition <: MethodDefinition, OrdinaryMethodDeclaration
    = Syntax:`IAbstractMethodDefinitionSyntax` /SelfParameter/ /Parameters/ /Return/;
OrdinaryMethodDefinition <: MethodDefinition, OrdinaryMethodDeclaration
    = Syntax:`IOrdinaryMethodDefinitionSyntax` /SelfParameter/ /Parameters/ /Return/ /Entry/ Body /Exit/;
GetterMethodDefinition <: MethodDefinition, GetterMethodDeclaration
    = Syntax:`IGetterMethodDefinitionSyntax` /SelfParameter/ /Parameters/ Return:Type /Entry/ Body? /Exit/;
SetterMethodDefinition <: MethodDefinition, SetterMethodDeclaration
    = Syntax:`ISetterMethodDefinitionSyntax` /SelfParameter/ /Parameters/ /Return/ /Entry/ Body /Exit/;
ConstructorDefinition <: InvocableDefinition, AlwaysTypeMemberDefinition, ClassMemberDefinition, ConstructorDeclaration
    = Syntax:`IConstructorDefinitionSyntax`? Parameters:ConstructorOrInitializerParameter*;
// TODO the term "default" can mean both generated and no-arg. Perhaps another term should be used?
DefaultConstructorDefinition <: ConstructorDefinition;
OrdinaryConstructorDefinition <: Code, ConstructorDefinition
    = Syntax:`IConstructorDefinitionSyntax`
    SelfParameter:ConstructorSelfParameter /Parameters/ /Entry/ Body:BlockBody /Exit/;
InitializerDefinition <: InvocableDefinition, AlwaysTypeMemberDefinition, StructMemberDefinition, ClassMemberDefinition, InitializerDeclaration
    = Syntax:`IInitializerDefinitionSyntax`? Name:`IdentifierName`? Parameters:ConstructorOrInitializerParameter*;
DefaultInitializerDefinition <: InitializerDefinition;
OrdinaryInitializerDefinition <: Code, InitializerDefinition
    = Syntax:`IInitializerDefinitionSyntax`
    SelfParameter:InitializerSelfParameter /Parameters/ /Entry/ Body:BlockBody /Exit/;
FieldDefinition <: Code, AlwaysTypeMemberDefinition, ClassMemberDefinition, StructMemberDefinition, NamedBinding, FieldDeclaration, ExecutableDefinition
    = Syntax:`IFieldDefinitionSyntax` TypeNode:Type /Entry/ Initializer:AmbiguousExpression? /Exit/;
AssociatedFunctionDefinition <: ConcreteFunctionInvocableDefinition, AlwaysTypeMemberDefinition, AssociatedMemberDefinition, AssociatedFunctionDeclaration
    = Syntax:`IAssociatedFunctionDefinitionSyntax` /Parameters/ /Return/ /Entry/ /Body/ /Exit/;

// ---------- Attributes
Attribute <: Code = Syntax:`IAttributeSyntax` TypeName:OrdinaryTypeName;

// ---------- Capabilities
CapabilityConstraint <: Code = Syntax:`ICapabilityConstraintSyntax`;
CapabilitySet <: CapabilityConstraint = Syntax:`ICapabilitySetSyntax`;
Capability <: CapabilityConstraint = Syntax:`ICapabilitySyntax`;

// ---------- Parameters
Parameter <: Code = Syntax:`IParameterSyntax`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter <: Parameter = Syntax:`IConstructorOrInitializerParameterSyntax`;
NamedParameter <: ConstructorOrInitializerParameter, LocalBinding
    = Syntax:`INamedParameterSyntax` TypeNode:Type;
SelfParameter <: Parameter, Binding = Syntax:`ISelfParameterSyntax`;
ConstructorSelfParameter <: SelfParameter = Syntax:`IConstructorSelfParameterSyntax` Capability;
InitializerSelfParameter <: SelfParameter = Syntax:`IInitializerSelfParameterSyntax` Capability;
MethodSelfParameter <: SelfParameter = Syntax:`IMethodSelfParameterSyntax` Constraint:CapabilityConstraint;
FieldParameter <: ConstructorOrInitializerParameter = Syntax:`IFieldParameterSyntax`;

// ---------- Function Parts
Body <: BodyOrBlock;
BlockBody <: Body = Syntax:`IBlockBodySyntax` Statements:BodyStatement*;
ExpressionBody <: Body = Syntax:`IExpressionBodySyntax` ResultStatement;

// ---------- Types
Type <: Code = Syntax:`ITypeSyntax`;
// TODO start from generalized names in syntax and rewrite to type names
TypeName <: Type = Syntax:`INameSyntax`;
UnqualifiedTypeName <: TypeName = Syntax:`IUnqualifiedNameSyntax`;
BuiltInTypeName <: UnqualifiedTypeName = Syntax:`IBuiltInTypeNameSyntax`;
OrdinaryTypeName <: UnqualifiedTypeName = Syntax:`IOrdinaryNameSyntax`;
IdentifierTypeName <: OrdinaryTypeName = Syntax:`IIdentifierNameSyntax`;
GenericTypeName <: OrdinaryTypeName = Syntax:`IGenericNameSyntax` TypeArguments:Type*;
QualifiedTypeName <: TypeName = Syntax:`IQualifiedNameSyntax` Context:TypeName TypeArguments:Type*;
OptionalType <: Type = Syntax:`IOptionalTypeSyntax` Referent:Type;
CapabilityType <: Type = Syntax:`ICapabilityTypeSyntax` Capability Referent:Type;
FunctionType <: Type = Syntax:`IFunctionTypeSyntax` Parameters:ParameterType* Return:Type;
ParameterType <: Code = Syntax:`IParameterTypeSyntax` Referent:Type;
ViewpointType <: Type = Syntax:`IViewpointTypeSyntax` Referent:Type;
CapabilityViewpointType <: ViewpointType = Syntax:`ICapabilityViewpointTypeSyntax` Capability Referent:Type;
SelfViewpointType <: ViewpointType = Syntax:`ISelfViewpointTypeSyntax` Referent:Type;

// ---------- Control Flow
ControlFlow <: Child;
Entry <: DataFlow;
Exit <: DataFlow;

// ---------- Data Flow
DataFlow <: ControlFlow;

// ---------- Statements
Statement <: Code, ControlFlow = Syntax:`IStatementSyntax`;
ResultStatement <: Statement, BlockOrResult
    = Syntax:`IResultStatementSyntax` Expression:AmbiguousExpression;
BodyStatement <: Statement = Syntax:`IBodyStatementSyntax`;
VariableDeclarationStatement <: BodyStatement, VariableBinding
    = Syntax:`IVariableDeclarationStatementSyntax` Capability? Type? Initializer:AmbiguousExpression?;
ExpressionStatement <: BodyStatement
    = Syntax:`IExpressionStatementSyntax` Expression:AmbiguousExpression;

// ---------- Patterns
Pattern <: Code, ControlFlow = Syntax:`IPatternSyntax`;
BindingContextPattern <: Pattern = Syntax:`IBindingContextPatternSyntax` Pattern Type?;
OptionalOrBindingPattern <: Pattern = Syntax:`IOptionalOrBindingPatternSyntax`;
BindingPattern <: OptionalOrBindingPattern, VariableBinding = Syntax:`IBindingPatternSyntax`;
OptionalPattern <: OptionalOrBindingPattern = Syntax:`IOptionalPatternSyntax` Pattern:OptionalOrBindingPattern;

// ---------- Expressions
/// An ambiguous expression is one that could mean one of several things and will be rewritten out of
/// existence.
temp AmbiguousExpression <: Code = Syntax:`IExpressionSyntax`;
Expression <: AmbiguousExpression, ControlFlow = Syntax:`IExpressionSyntax`;
BlockExpression <: Expression, BlockOrResult, BodyOrBlock
    = Syntax:`IBlockExpressionSyntax` Statements:Statement*;
NewObjectExpression <: InvocationExpression = Syntax:`INewObjectExpressionSyntax`
    ConstructingType:TypeName Arguments:AmbiguousExpression*;
UnsafeExpression <: Expression = Syntax:`IUnsafeExpressionSyntax` Expression:AmbiguousExpression;
NeverTypedExpression <: Expression;

// ---------- Unresolved Expressions
/// An unresolved expression is one that hasn't had name binding on it. Expressions where name
/// binding fails can stay unresolved.
UnresolvedExpression <: Expression;
concrete UnresolvedMemberAccessExpression <: UnresolvedExpression
    = Syntax:`IMemberAccessExpressionSyntax` Context:AmbiguousExpression TypeArguments:Type*;

// ---------- Literal Expressions
LiteralExpression <: Expression = Syntax:`ILiteralExpressionSyntax`;
BoolLiteralExpression <: LiteralExpression = Syntax:`IBoolLiteralExpressionSyntax`;
IntegerLiteralExpression <: LiteralExpression = Syntax:`IIntegerLiteralExpressionSyntax`;
NoneLiteralExpression <: LiteralExpression = Syntax:`INoneLiteralExpressionSyntax`;
StringLiteralExpression <: LiteralExpression = Syntax:`IStringLiteralExpressionSyntax`;

// ---------- Operator Expressions
AssignmentExpression <: Expression, DataFlow = Syntax:`IAssignmentExpressionSyntax`
    LeftOperand:AmbiguousExpression RightOperand:AmbiguousExpression;
BinaryOperatorExpression <: Expression = Syntax:`IBinaryOperatorExpressionSyntax`
    LeftOperand:AmbiguousExpression RightOperand:AmbiguousExpression;
UnaryOperatorExpression <: Expression = Syntax:`IUnaryOperatorExpressionSyntax`
     Operand:AmbiguousExpression;
ConversionExpression <: Expression = Syntax:`IConversionExpressionSyntax`
    Referent:AmbiguousExpression ConvertToType:Type;
ImplicitConversionExpression <: Expression = Referent:Expression PlainType:`BarePlainType`;
PatternMatchExpression <: Expression
    = Syntax:`IPatternMatchExpressionSyntax` Referent:AmbiguousExpression Pattern;

// ---------- Control Flow Expressions
IfExpression <: Expression, ElseClause = Syntax:`IIfExpressionSyntax`
    Condition:AmbiguousExpression ThenBlock:BlockOrResult ElseClause?;
LoopExpression <: Expression = Syntax:`ILoopExpressionSyntax` Block:BlockExpression;
WhileExpression <: Expression = Syntax:`IWhileExpressionSyntax`
    Condition:AmbiguousExpression Block:BlockExpression;
ForeachExpression <: Expression, VariableBinding = Syntax:`IForeachExpressionSyntax`
    InExpression:AmbiguousExpression DeclaredType:Type? Block:BlockExpression;
BreakExpression <: NeverTypedExpression = Syntax:`IBreakExpressionSyntax`
    Value:AmbiguousExpression?;
NextExpression <: NeverTypedExpression = Syntax:`INextExpressionSyntax`;
ReturnExpression <: NeverTypedExpression
    = Syntax:`IReturnExpressionSyntax` Value:AmbiguousExpression?;

// ---------- Invocation Expressions
InvocationExpression <: Expression;
UnresolvedInvocationExpression <: InvocationExpression, UnresolvedExpression
    = Syntax:`IInvocationExpressionSyntax`
    Expression:AmbiguousExpression Arguments:AmbiguousExpression*;
FunctionInvocationExpression <: InvocationExpression = Syntax:`IInvocationExpressionSyntax`
    Function:FunctionName Arguments:AmbiguousExpression*;
MethodInvocationExpression <: InvocationExpression = Syntax:`IInvocationExpressionSyntax`
    Method:MethodName Arguments:AmbiguousExpression*;
GetterInvocationExpression <: InvocationExpression, NameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:Expression PropertyName:`OrdinaryName`
    ReferencedDeclarations:{`IPropertyAccessorDeclarationNode`};
SetterInvocationExpression <: InvocationExpression = Syntax:`IAssignmentExpressionSyntax`
    Context:Expression PropertyName:`OrdinaryName` Value:AmbiguousExpression
    ReferencedDeclarations:{`IPropertyAccessorDeclarationNode`};
FunctionReferenceInvocationExpression <: InvocationExpression = Syntax:`IInvocationExpressionSyntax`
    Expression:Expression Arguments:AmbiguousExpression*;
InitializerInvocationExpression <: InvocationExpression = Syntax:`IInvocationExpressionSyntax`
    Initializer:InitializerName Arguments:AmbiguousExpression*;
NonInvocableInvocationExpression <: InvocationExpression = Syntax:`IInvocationExpressionSyntax`
    Expression:AmbiguousExpression Arguments:AmbiguousExpression*;

// ---------- Ambiguous Name Expressions
// TODO consider renaming to `UnresolvedNameExpression` because the final tree could have a bound
// name that is still ambiguous (e.g. could not determine what it refers to). However, perhaps another
// name is needed to distinguish between unresolved nodes and temp nodes.
temp AmbiguousNameExpression <: AmbiguousExpression = Syntax:`INameExpressionSyntax`;
temp AmbiguousName <: AmbiguousNameExpression;
temp OrdinaryNameExpression <: AmbiguousName = Syntax:`IOrdinaryNameSyntax`;
temp IdentifierNameExpression <: AmbiguousName, OrdinaryNameExpression
    = Syntax:`IIdentifierNameSyntax`;
temp GenericNameExpression <: AmbiguousName, OrdinaryNameExpression
    = Syntax:`IGenericNameSyntax` TypeArguments:Type*;

// ---------- Name Expressions
NameExpression <: Expression, AmbiguousNameExpression = Syntax:`INameExpressionSyntax`;
LocalBindingNameExpression <: NameExpression = ReferencedDefinition:`IBindingNode`?;
// TODO Name <: NameExpression
NamespaceName <: NameExpression = ReferencedDeclarations:`INamespaceDeclarationNode`*;
UnqualifiedNamespaceName <: NamespaceName
    = Syntax:`IIdentifierNameSyntax` /ReferencedDeclarations/;
QualifiedNamespaceName <: NamespaceName
    = Syntax:`IMemberAccessExpressionSyntax` Context:NamespaceName /ReferencedDeclarations/;
FunctionGroupName <: NameExpression
    = Syntax:`INameExpressionSyntax` Context:NameExpression? FunctionName:`OrdinaryName` TypeArguments:Type*
    ReferencedDeclarations:{`IFunctionInvocableDeclarationNode`};
/// Reifying to FunctionName controls the transition from UnresolvedInvocation to FunctionInvocation.
/// The UnresolvedInvocation provides an expected type based on the arguments. Once the overload has
/// been resolved, the FunctionInvocation provides expected types based on the function called.
FunctionName <: NameExpression
    = Syntax:`INameExpressionSyntax` Context:NameExpression?  FunctionName:`OrdinaryName` TypeArguments:Type*
    ReferencedDeclarations:{`IFunctionInvocableDeclarationNode`}
    CallCandidates:{`ICallCandidate<IFunctionInvocableDeclarationNode>`}
    CompatibleCallCandidates:{`ICallCandidate<IFunctionInvocableDeclarationNode>`}
    SelectedCallCandidate:`ICallCandidate<IFunctionInvocableDeclarationNode>`?
    ReferencedDeclaration:`IFunctionInvocableDeclarationNode`?;
MethodGroupName <: NameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:Expression MethodName:`OrdinaryName` TypeArguments:Type*
    ReferencedDeclarations:{`IOrdinaryMethodDeclarationNode`};
/// See comment on FunctionName for why this exists.
MethodName <: NameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:Expression MethodName:`OrdinaryName` TypeArguments:Type*
    ReferencedDeclarations:{`IOrdinaryMethodDeclarationNode`}
    CallCandidates:{`ICallCandidate<IOrdinaryMethodDeclarationNode>`}
    CompatibleCallCandidates:{`ICallCandidate<IOrdinaryMethodDeclarationNode>`}
    SelectedCallCandidate:`ICallCandidate<IOrdinaryMethodDeclarationNode>`?
    ReferencedDeclaration:`IOrdinaryMethodDeclarationNode`?;
FieldAccessExpression <: NameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:Expression FieldName:`IdentifierName` ReferencedDeclaration:`IFieldDeclarationNode`;
VariableNameExpression <: LocalBindingNameExpression, NameExpression
    = Syntax:`IIdentifierNameSyntax` ReferencedDefinition:`ILocalBindingNode`;
TypeNameExpression <: NameExpression = Syntax:`INameExpressionSyntax`
    TypeArguments:Type* ReferencedDeclaration:`ITypeDeclarationNode`;
// TODO rename to UnqualifiedTypeNameExpression
OrdinaryTypeNameExpression <: TypeNameExpression
    = Syntax:`IOrdinaryNameSyntax` /TypeArguments/ /ReferencedDeclaration/;
QualifiedTypeNameExpression <: TypeNameExpression = Syntax:`IMemberAccessExpressionSyntax`
    Context:NamespaceName /TypeArguments/ /ReferencedDeclaration/;
InitializerGroupName <: NameExpression = Syntax:`INameExpressionSyntax`
    Context:TypeNameExpression InitializerName:`OrdinaryName`?
    ReferencedDeclarations:{`IInitializerDeclarationNode`};
/// See comment on FunctionName for why this exists.
InitializerName <: NameExpression = Syntax:`INameExpressionSyntax`
    Context:TypeNameExpression InitializerName:`OrdinaryName`?
    ReferencedDeclarations:{`IInitializerDeclarationNode`}
    CallCandidates:{`ICallCandidate<IInitializerDeclarationNode>`}
    CompatibleCallCandidates:{`ICallCandidate<IInitializerDeclarationNode>`}
    SelectedCallCandidate:`ICallCandidate<IInitializerDeclarationNode>`?
    ReferencedDeclaration:`IInitializerDeclarationNode`?;
// TODO merge with BuiltInTypeName and keep the name "BuiltInTypeName" because it really isn't an expression
BuiltInTypeNameExpression <: NameExpression
    = Syntax:`IBuiltInTypeNameSyntax`;
InstanceExpression <: NameExpression = Syntax:`IInstanceExpressionSyntax`; // i.e. `self` or `base`
// TODO BaseExpression <: InstanceExpression
SelfExpression <: InstanceExpression, LocalBindingNameExpression
    = Syntax:`ISelfExpressionSyntax`;
MissingNameExpression <: NameExpression
    = Syntax:`IMissingNameSyntax`;

// ---------- Unresolved Name Expressions
UnresolvedNameExpression <: NameExpression, UnresolvedExpression = Syntax:`INameExpressionSyntax`;
UnresolvedOrdinaryNameExpression <: UnresolvedNameExpression
    = Syntax:`IOrdinaryNameSyntax` Name:`OrdinaryName`;
UnresolvedIdentifierNameExpression <: UnresolvedOrdinaryNameExpression
    = Syntax:`IIdentifierNameSyntax`;
UnresolvedGenericNameExpression <: UnresolvedOrdinaryNameExpression
    = Syntax:`IGenericNameSyntax` TypeArguments:Type*;
// TODO Context should be a name
UnresolvedQualifiedNameExpression <: UnresolvedNameExpression, UnresolvedMemberAccessExpression
    = Syntax:`IQualifiedNameSyntax` /Context/ /TypeArguments/;

// ---------- Capability Expressions
temp AmbiguousMoveExpression <: AmbiguousExpression = Syntax:`IMoveExpressionSyntax` Referent:AmbiguousExpression;
RecoveryExpression <: Expression = Referent:Expression IsImplicit:`bool`;
MoveExpression <: RecoveryExpression = Referent:Expression;
// TODO why is move variable expression needed? Shouldn't moving a value just change any variables in the sharing set to `id`?
MoveVariableExpression <: MoveExpression = Referent:LocalBindingNameExpression /IsImplicit/;
MoveValueExpression <: MoveExpression = /Referent/ /IsImplicit/;
ImplicitTempMoveExpression <: Expression = Referent:Expression;
temp AmbiguousFreezeExpression <: AmbiguousExpression = Syntax:`IFreezeExpressionSyntax` Referent:AmbiguousExpression;
FreezeExpression <: RecoveryExpression = Referent:Expression IsTemporary:`bool`;
FreezeVariableExpression <: FreezeExpression = Referent:LocalBindingNameExpression /IsTemporary/ /IsImplicit/;
FreezeValueExpression <: FreezeExpression = /Referent/ /IsTemporary/ /IsImplicit/;
PrepareToReturnExpression <: Expression = Value:Expression;

// ---------- Async Expressions
AsyncBlockExpression <: Expression = Syntax:`IAsyncBlockExpressionSyntax` Block:BlockExpression;
AsyncStartExpression <: Expression
    = Syntax:`IAsyncStartExpressionSyntax` Expression:AmbiguousExpression;
AwaitExpression <: Expression = Syntax:`IAwaitExpressionSyntax` Expression:AmbiguousExpression;

// -------------------------------------------------------------------------------------------------
// Declarations
// -------------------------------------------------------------------------------------------------
// Declarations are the abstractions of both definitions and symbols. They are used to represent
// what a name can refer to.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

Declaration;
ChildDeclaration <: Declaration, Child;
NamedDeclaration <: ChildDeclaration;
SymbolDeclaration <: Declaration;

// ---------- Bindings
BindingDeclaration <: ChildDeclaration;
NamedBindingDeclaration <: BindingDeclaration, NamedDeclaration;

// ---------- Package Declarations
PackageDeclaration <: SymbolDeclaration = AliasOrName:`IdentifierName`? Name:`IdentifierName`
    MainFacet:PackageFacetDeclaration TestingFacet:PackageFacetDeclaration;

// ---------- Facet Declarations
/// Facets separate the testing and non-testing aspects of a package. They do no have their own
/// symbol. They use the package symbol.
PackageFacetDeclaration <: ChildDeclaration, SymbolDeclaration;

// TODO better name for this
// Any child declaration node of a facet (not just members)
PackageFacetChildDeclaration <: ChildDeclaration;

// ---------- Declarations
InvocableDeclaration <: SymbolDeclaration, ChildDeclaration;
FunctionInvocableDeclaration <: NamedDeclaration, InvocableDeclaration;

// ---------- Namespace Declarations
NamespaceDeclaration <: NamespaceMemberDeclaration;
NamespaceMemberDeclaration <: PackageFacetChildDeclaration, NamedDeclaration, SymbolDeclaration
    = Name:`OrdinaryName`;

// ---------- Function Declaration
FunctionDeclaration <: NamespaceMemberDeclaration, FunctionInvocableDeclaration;

// ---------- Type Declarations
TypeDeclaration <: NamedDeclaration, SymbolDeclaration;
// TODO this needs a better name
NonVariableTypeDeclaration <: TypeDeclaration;
BuiltInTypeDeclaration <: NonVariableTypeDeclaration = Name:`BuiltInTypeName` Members:{TypeMemberDeclaration};
// TODO should this be renamed Ordinary?
UserTypeDeclaration <: NamespaceMemberDeclaration, ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, NonVariableTypeDeclaration
    = Name:`OrdinaryName` GenericParameters:GenericParameterDeclaration* Members:{TypeMemberDeclaration};
ClassDeclaration <: UserTypeDeclaration = Members:{ClassMemberDeclaration};
StructDeclaration <: UserTypeDeclaration = Members:{StructMemberDeclaration};
TraitDeclaration <: UserTypeDeclaration = Members:{TraitMemberDeclaration};

// ---------- Type Declaration Parts
GenericParameterDeclaration <: TypeDeclaration, AssociatedMemberDeclaration
    = Name:`IdentifierName` Members:{TypeMemberDeclaration};
ImplicitSelfDeclaration <: TypeDeclaration;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberDeclaration <: PackageFacetChildDeclaration, SymbolDeclaration;
ClassMemberDeclaration <: TypeMemberDeclaration;
TraitMemberDeclaration <: TypeMemberDeclaration;
StructMemberDeclaration <: TypeMemberDeclaration;
AlwaysTypeMemberDeclaration <: TypeMemberDeclaration;
AssociatedMemberDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, SymbolDeclaration;
InstanceMemberDeclaration <: TypeMemberDeclaration;

// ---------- Member Declarations
MethodDeclaration <: ClassMemberDeclaration, TraitMemberDeclaration, StructMemberDeclaration, NamedDeclaration, InstanceMemberDeclaration, InvocableDeclaration, AlwaysTypeMemberDeclaration
    = Name:`IdentifierName`;
OrdinaryMethodDeclaration <: MethodDeclaration;
PropertyAccessorDeclaration <: MethodDeclaration;
GetterMethodDeclaration <: PropertyAccessorDeclaration;
SetterMethodDeclaration <: PropertyAccessorDeclaration;
ConstructorDeclaration <: ClassMemberDeclaration, AssociatedMemberDeclaration, InvocableDeclaration, AlwaysTypeMemberDeclaration
    = Name:`IdentifierName`?;
InitializerDeclaration <: StructMemberDeclaration, ClassMemberDeclaration, AssociatedMemberDeclaration, InvocableDeclaration, AlwaysTypeMemberDeclaration
    = Name:`IdentifierName`?;
FieldDeclaration <: NamedDeclaration, ClassMemberDeclaration, StructMemberDeclaration, InstanceMemberDeclaration, NamedBindingDeclaration, AlwaysTypeMemberDeclaration
    = Name:`IdentifierName`;
AssociatedFunctionDeclaration <: AssociatedMemberDeclaration, FunctionInvocableDeclaration, InvocableDeclaration, AlwaysTypeMemberDeclaration
    = Name:`OrdinaryName`;

// -------------------------------------------------------------------------------------------------
// Symbol Nodes
// -------------------------------------------------------------------------------------------------
// Implementations of declarations that are derived from symbols.
// -------------------------------------------------------------------------------------------------
// TODO move into separate aspect

// ---------- Parent Symbol Nodes
ChildSymbol <: SymbolDeclaration, ChildDeclaration;

// ---------- Package Symbol Nodes
PackageSymbol <: PackageDeclaration, ChildSymbol
    = PackageReference:`IPackageReferenceNode` /MainFacet/ /TestingFacet/;

// ---------- Facet Symbol Nodes
// Facets separate the testing and non-testing aspects of a package. They do no have their own symbol.
PackageFacetSymbol <: PackageFacetDeclaration, ChildSymbol = SymbolTree:`FixedSymbolTree`;

// ---------- Namespace Symbol Nodes
NamespaceSymbol <: NamespaceDeclaration, NamespaceMemberSymbol = Symbol:`NamespaceSymbol`;
NamespaceMemberSymbol <: NamespaceMemberDeclaration, ChildSymbol;

// ---------- Function Symbol Nodes
FunctionSymbol <: FunctionDeclaration, NamespaceMemberSymbol = Symbol:`FunctionSymbol`;

// ---------- Type Symbol Nodes
TypeSymbol <: TypeDeclaration, ChildSymbol = Symbol:`TypeSymbol`;
NonVariableTypeSymbol <: NonVariableTypeDeclaration, TypeSymbol;
BuiltInTypeSymbol <: BuiltInTypeDeclaration, NonVariableTypeSymbol = Symbol:`BuiltInTypeSymbol`;
VoidTypeSymbol <: TypeSymbol = Symbol:`VoidTypeSymbol`;
NeverTypeSymbol <: TypeSymbol = Symbol:`NeverTypeSymbol`;
OrdinaryTypeSymbol <: UserTypeDeclaration, NonVariableTypeSymbol, NamespaceMemberSymbol = Symbol:`OrdinaryTypeSymbol`;
ClassSymbol <: ClassDeclaration, OrdinaryTypeSymbol = /GenericParameters/ /Members/;
StructSymbol <: StructDeclaration, OrdinaryTypeSymbol = /GenericParameters/ /Members/;
TraitSymbol <: TraitDeclaration, OrdinaryTypeSymbol = /GenericParameters/ /Members/;

// ---------- Type Declaration Parts
GenericParameterSymbol <: GenericParameterDeclaration, TypeSymbol = Symbol:`GenericParameterTypeSymbol`;
SelfSymbol <: ImplicitSelfDeclaration = Symbol:`AssociatedTypeSymbol`;

// ---------- Type Member Declarations (i.e. declarations that can be contained in a type)
TypeMemberSymbol <: TypeMemberDeclaration, ChildSymbol;
ClassMemberSymbol <: ClassMemberDeclaration, TypeMemberSymbol;
TraitMemberSymbol <: TraitMemberDeclaration, TypeMemberSymbol;
StructMemberSymbol <: StructMemberDeclaration, TypeMemberSymbol;
AssociatedMemberSymbol <: AssociatedMemberDeclaration, ClassMemberSymbol, TraitMemberSymbol, StructMemberSymbol;

// ---------- Member Symbol Nodes
MethodSymbol <: MethodDeclaration, ClassMemberSymbol, TraitMemberSymbol, StructMemberSymbol
    = Symbol:`MethodSymbol`;
OrdinaryMethodSymbol <: OrdinaryMethodDeclaration, MethodSymbol;
GetterMethodSymbol <: GetterMethodDeclaration, MethodSymbol;
SetterMethodSymbol <: SetterMethodDeclaration, MethodSymbol;
ConstructorSymbol <: ConstructorDeclaration, ClassMemberSymbol = Symbol:`ConstructorSymbol`;
InitializerSymbol <: InitializerDeclaration, StructMemberSymbol, ClassMemberSymbol = Symbol:`InitializerSymbol`;
FieldSymbol <: FieldDeclaration, ClassMemberSymbol, StructMemberSymbol = Symbol:`FieldSymbol`;
AssociatedFunctionSymbol <: AssociatedFunctionDeclaration, AssociatedMemberSymbol
    = Symbol:`FunctionSymbol`;
