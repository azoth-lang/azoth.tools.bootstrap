◊namespace Azoth.Tools.Bootstrap.Compiler.AST;
◊base 'IAbstractSyntax';
◊prefix I;
◊list FixedList;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Promises;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Framework;

'IAbstractSyntax' = Span:'TextSpan';

// ---------- Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding = Symbol:'BindingSymbol';
LocalBinding: Binding = Symbol:'NamedBindingSymbol';

// ---------- Declarations
// Note: in the AST all declarations are entities because there are no namespace declarations
Declaration = File:'CodeFile' Symbol:'Symbol' NameSpan:'TextSpan';
/// A declaration that could contain executable code (i.e. invocable declaration or field declaration)
ExecutableDeclaration: Declaration;
InvocableDeclaration: Declaration = Symbol:'InvocableSymbol' Parameters:ConstructorParameter*;
ConcreteInvocableDeclaration: InvocableDeclaration, ExecutableDeclaration = Body;
ConcreteFunctionInvocableDeclaration: ConcreteInvocableDeclaration = Symbol:'FunctionSymbol' Parameters:NamedParameter* Body;

// ---------- Non-Member Declarations
NonMemberDeclaration: Declaration;
TypeDeclaration: NonMemberDeclaration = Symbol:'ObjectTypeSymbol' Members:MemberDeclaration*;
ClassDeclaration: TypeDeclaration = Symbol:'ObjectTypeSymbol' Members:ClassMemberDeclaration* DefaultConstructorSymbol:'ConstructorSymbol'?;
TraitDeclaration: TypeDeclaration = Symbol:'ObjectTypeSymbol' Members:TraitMemberDeclaration*;
FunctionDeclaration: NonMemberDeclaration, ConcreteFunctionInvocableDeclaration = Symbol:'FunctionSymbol' Parameters:NamedParameter* Body;

// ---------- Member Declarations
// Note: by declaring the DeclaringType property type with quotes, it avoids the system assuming it must represent a child node
MemberDeclaration: Declaration = DeclaringType:'ITypeDeclaration';
ClassMemberDeclaration: MemberDeclaration;
TraitMemberDeclaration: MemberDeclaration;
MethodDeclaration: ClassMemberDeclaration, TraitMemberDeclaration = Symbol:'MethodSymbol' SelfParameter Parameters:NamedParameter*;
AbstractMethodDeclaration: MethodDeclaration = SelfParameter Parameters:NamedParameter*;
ConcreteMethodDeclaration: MethodDeclaration, ConcreteInvocableDeclaration = Symbol:'MethodSymbol' SelfParameter Parameters:NamedParameter* Body;
ConstructorDeclaration: ClassMemberDeclaration, ConcreteInvocableDeclaration = DeclaringType:'IClassDeclaration' Symbol:'ConstructorSymbol' SelfParameter Parameters:ConstructorParameter* Body;
FieldDeclaration: ClassMemberDeclaration, ExecutableDeclaration, Binding = DeclaringType:'IClassDeclaration' Symbol:'FieldSymbol';
AssociatedFunctionDeclaration: ClassMemberDeclaration, TraitMemberDeclaration, ConcreteFunctionInvocableDeclaration = Symbol:'FunctionSymbol' Parameters:NamedParameter* Body;

// ---------- Parameters --------------
Parameter = Unused:'bool';
/// A parameter that can be declared in a constructor
ConstructorParameter: Parameter;
/// A parameter that creates a binding, i.e. a named or self parameter
BindingParameter: Parameter, Binding;
NamedParameter: Parameter, ConstructorParameter, BindingParameter, LocalBinding = Symbol:'VariableSymbol' DefaultValue:Expression?;
SelfParameter: Parameter, BindingParameter = Symbol:'SelfParameterSymbol';
FieldParameter: Parameter, ConstructorParameter = ReferencedSymbol:'FieldSymbol' DefaultValue:Expression?;

// ---------- Function Parts
Body: BodyOrBlock = Statements:BodyStatement*;

// ---------- Statements
Statement;
ResultStatement: Statement, BlockOrResult = Expression;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement, LocalBinding = NameSpan:'TextSpan' Symbol:'VariableSymbol' Initializer:Expression? VariableIsLiveAfter:'Promise<bool>';
ExpressionStatement: BodyStatement = Expression;

// ---------- Expressions
Expression = DataType:'DataType' Semantics:'ExpressionSemantics';
AssignableExpression: Expression;
BlockExpression: Expression, BlockOrResult, BodyOrBlock = Statements:Statement*;
NewObjectExpression: Expression =  ReferencedSymbol:'ConstructorSymbol' Arguments:Expression*;
UnsafeExpression: Expression = Expression;

// ---------- Literal Expressions
LiteralExpression: Expression;
BoolLiteralExpression: LiteralExpression = Value:'bool';
IntegerLiteralExpression: LiteralExpression = Value:'BigInteger';
NoneLiteralExpression: LiteralExpression;
StringLiteralExpression: LiteralExpression = Value:'string';

// ---------- Operator Expressions
AssignmentExpression: Expression = LeftOperand:AssignableExpression Operator:'AssignmentOperator' RightOperand:Expression;
BinaryOperatorExpression: Expression = LeftOperand:Expression Operator:'BinaryOperator' RightOperand:Expression;
UnaryOperatorExpression: Expression = Fixity:'UnaryOperatorFixity' Operator:'UnaryOperator' Operand:Expression;

// ---------- Control Flow Expressions
IfExpression: Expression, ElseClause = Condition:Expression ThenBlock:BlockOrResult ElseClause?;
LoopExpression: Expression = Block:BlockExpression;
WhileExpression: Expression = Condition:Expression Block:BlockExpression;
ForeachExpression: Expression, LocalBinding = Symbol:'VariableSymbol' InExpression:Expression Block:BlockExpression VariableIsLiveAfterAssignment:'Promise<bool>';
BreakExpression: Expression = Value:Expression?;
NextExpression: Expression;
ReturnExpression: Expression = Value:Expression?;

// ---------- Implicit Conversion Expressions
ImplicitConversionExpression: Expression = Expression DataType:'DataType';
//ImplicitImmutabilityConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'ObjectType';
ImplicitNumericConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'NumericType';
ImplicitOptionalConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'OptionalType';
ImplicitLiftedConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'OptionalType';

// ----------- Explicit Conversion Expressions
ExplicitConversionExpression: Expression = Expression IsOptional:'bool' DataType:'DataType';
ExplicitNumericConversionExpression: ExplicitConversionExpression = Expression ConvertToType:'NumericType';

// ---------- Invocation Expressions
InvocationExpression: Expression = ReferencedSymbol:'InvocableSymbol' Arguments:Expression*;
FunctionInvocationExpression: InvocationExpression = ReferencedSymbol:'FunctionSymbol' Arguments:Expression*;
MethodInvocationExpression: InvocationExpression = Context:Expression ReferencedSymbol:'MethodSymbol' Arguments:Expression*;

// ---------- Variable Expressions
NameExpression: AssignableExpression = ReferencedSymbol:'NamedBindingSymbol' VariableIsLiveAfter:'Promise<bool>';
SelfExpression: Expression = ReferencedSymbol:'SelfParameterSymbol' IsImplicit:'bool';
FieldAccessExpression: AssignableExpression = Context:Expression AccessOperator:'AccessOperator' ReferencedSymbol:'FieldSymbol';
MoveExpression: Expression = ReferencedSymbol:'BindingSymbol' Referent:Expression;
FreezeExpression: Expression = ReferencedSymbol:'BindingSymbol' Referent:Expression;
ShareExpression: Expression = ReferencedSymbol:'BindingSymbol' Referent:Expression;
IdExpression: Expression = Referent:Expression;

// ---------- Recover Expressions
RecoverExpression: Expression = Value:Expression;
RecoverConstExpression: RecoverExpression = Value:Expression;
RecoverIsolationExpression: RecoverExpression = Value:Expression;
