# Azoth.Tools.Bootstrap.Compiler.Syntax

This project contains a concrete syntax tree generated by the parser. It should not
contain any semantic analysis. The nodes do not contain parent references.

Currently, this tree and the parser make some semantic distinctions they should not. For example,
disallowing certain expressions to the left of an assignment and disallowing certain definitions
with traits, structs and classes.

Both tokens and syntax nodes have a separate interface and implementation layer. Other parts of the
compiler deal only with the interfaces. For both the tokens and syntax tree, transitioning to this
separation brought a lot of improvement. Even though it produces more code, the flexibility of
multiple inheritance hierarchies is very powerful and enables stronger typing.

The syntax tree is designed to be as concrete as possible. Meaning that each different kind of
syntax construct has a separate node type. For example, it used to be the case that functions,
methods, and associated functions were all the same node type. Now, each has a different node type.
This has improved type safety by ensuring nodes have exactly the properties that make sense for them
and that those properties have correct nullability. However, perhaps this has gone to far and
functions and associated functions should actually be the same node type since there doesn't seem to
be any difference between them other than their context.

## Naming Conventions

Each syntax interface ends in `Syntax` to distinguish them. The category of the node is also in the
name. While including the category is more verbose, not doing so leads to inconsistencies. There are
always some node types for which leaving out the category produces a confusing name. Categories are:

* Definition
* Statement
* Expression
  * OperatorExpression
  * LiteralExpression
  * ConversionExpression
* Parameter
* Type

## Traversing the Syntax Tree

Tree traversal is done with pattern matching on node type and with the `Children()` method. Previous
iterations had more sophisticated mechanisms. However, with the new attribute grammar approach of
the semantic analysis phase, traversing the tree has become less of an issue and there is far less
code that does it. Also, the use of the `ExhaustiveMatching.Analyzer` makes it safe to match on the
node type and get errors when a case is missed. Also, the `Children()` method avoids the need to
update a traversal of all nodes when a child property is added to a node.

It took a while to arrive at these as the traversal approach. Methods on the nodes with overrides
were ruled out early since there may be many traversals and they are too hard to work on if they are
spread out among all the node classes. Instead, the visitor pattern was originally the preferred
method of traversing the AST. This was very cumbersome though. It also made it very difficult to
handle multiple node types as a single case. At one point, there was experimentation with using
reflection to safely implement visitors but that was confusing to refactoring tools and spread the
code out among many methods just like a visitor. Using switch statements to match on type was a near
ideal syntax, but without exhaustiveness checking, it was incredibly error prone. With the creation
and use of the `ExhaustiveMatching.Analyzer` package that provides the most flexible exhaustiveness
checking of any language, that has changed. Now switching on type is the preferred approach in many
cases.

## Separate Syntax Tree

Having a separate syntax tree from the semantic tree was modeled on the Roslyn compiler. It also
made a lot of sense when a pass was required to compute properties of the semantic tree and build
that tree up. It allowed the semantic tree to have many non-nullable properties. With the attribute
grammar approach, that is no longer an issues. It might make sense to directly build the semantic
tree from the parser. However, there are still a number of reasons the two trees are being kept
separate.

1. It could be difficult to maintain property syntax location data in the semantic tree while node
   rewrites are happening. Having a syntax tree makes that easy and ensures the syntax tree is
   immutable.
2. Eventually, incremental lexing and parsing as supported by Roslyn would be good to implement. The
   plan is that the current syntax tree would be that tree with modifications to make it a red-green
   tree as used in Roslyn. (Or perhaps this syntax tree could act as the "green" tree and the
   semantic tree could act as the "red" tree with parent references and computation of text spans
   from text widths.)

## Design Goals

### Adaptability to Syntax Changes

As the language is still being designed, it is important that the lexer, parser and concrete syntax
tree be easy to modify. This is supported by keeping them as simple as possible. Code generation is
used for tokens so that tokens can be easily added and removed. Several points in the lexer use
generated lists of all tokens of a given type to guide the lexing process. Code generation is also
used for the tree node types.

### Correct by Construction

Originally, tokens were not as strongly typed. They were using several struct types with an enum for
the token type. This performance optimization was modelled on the Roslyn C# compiler. However, it
was decided that having strongly typed tokens was more valuable and the transition was made to the
current set of classes. This also allowed for more sophisticated type relationships such as a base
class for keywords and a base class for operators. Ideally, missing tokens would be represented with
a special token that included the type and position of the missing token. However, the C# type
system didn't offer good options for representing that in a strongly typed way. It was decided to
use `null` to represent missing tokens and accept the limitations that might imply.
