◊namespace Azoth.Tools.Bootstrap.Compiler.Syntax;
◊name FormattingAspect;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;

// Attribute Syntax
// ----------------
// Synthesized:
//      ↑ (child)? Node.Attribute:TypeSymbol (=> <C# Expression>)?;
//      ↑ (child)? Node.Method(<params>):TypeSymbol (=> <C# Expression>)?;
//      = (eager|lazy|computed)? Node.Attribute(:TypeSymbol)? (=> <C# Expression>)?;
//      = Node.Method(<params>)(:TypeSymbol)? (=> <C# Expression>)?;
// Inherited:
//      ↓ (computed)? (child)? Node.Attribute:TypeSymbol;
//      ↓ (child)? Node.Method():TypeSymbol; // Always computed
//      = Node.*.(Attribute|Method()) (=> <C# Expression>)?;
//      = Node.**.(Attribute|Method()) (=> <C# Expression>)?; // Broadcast
//      = Node.Child.(Attribute|Method()) (=> <C# Expression>)?;
//      = Node.ChildList[i].(Attribute|Method()) (=> <C# Expression>)?;
//      = Node.Child.**.(Attribute|Method()) (=> <C# Expression>)?; // Broadcast
// Inherited from Previous: ⮡  (child)? Node.Attribute:TypeSymbol;
// Circular: ⟳ Node.Attribute:TypeSymbol;
// Collection: [*] Node.Attribute:TypeSymbol; // TODO how to set builders?

// ---------- Expressions
↑ Expression.ToGroupedString(OperatorPrecedence surroundingPrecedence): `string`
    => surroundingPrecedence > ExpressionPrecedence ? $"({this})" : ToString();
↑ Expression.ExpressionPrecedence:`OperatorPrecedence`;
= BlockExpression.ExpressionPrecedence => OperatorPrecedence.Primary;
= NewObjectExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= UnsafeExpression.ExpressionPrecedence => OperatorPrecedence.Primary;

// ---------- Literal Expressions
= LiteralExpression.ExpressionPrecedence => OperatorPrecedence.Primary;

// ---------- Operator Expressions
= AssignmentExpression.ExpressionPrecedence => OperatorPrecedence.Assignment;
= BinaryOperatorExpression.ExpressionPrecedence => Operator.Precedence();
= UnaryOperatorExpression.ExpressionPrecedence => OperatorPrecedence.Unary;
= IdExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= ConversionExpression.ExpressionPrecedence => OperatorPrecedence.Conversion;
= PatternMatchExpression.ExpressionPrecedence => OperatorPrecedence.Conversion;

// ---------- Control Flow Expressions
= IfExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= LoopExpression.ExpressionPrecedence => OperatorPrecedence.Primary;
= WhileExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= ForeachExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= BreakExpression.ExpressionPrecedence => Value is not null ? OperatorPrecedence.Min : OperatorPrecedence.Primary;
= NextExpression.ExpressionPrecedence => OperatorPrecedence.Primary;
= ReturnExpression.ExpressionPrecedence => OperatorPrecedence.Min;

// ---------- Invocation Expressions
= InvocationExpression.ExpressionPrecedence => OperatorPrecedence.Primary;

// ---------- Name Expressions
= NameExpression.ExpressionPrecedence => OperatorPrecedence.Primary;

// ---------- Capability Expressions
= MoveExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= FreezeExpression.ExpressionPrecedence => OperatorPrecedence.Min;

// ---------- Async Expressions
= AsyncBlockExpression.ExpressionPrecedence => OperatorPrecedence.Primary;
= AsyncStartExpression.ExpressionPrecedence => OperatorPrecedence.Min;
= AwaitExpression.ExpressionPrecedence => OperatorPrecedence.Unary;
