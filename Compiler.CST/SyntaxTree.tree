◊namespace Azoth.Tools.Bootstrap.Compiler.CST;
◊root Concrete;
◊prefix I;
◊suffix Syntax;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Promises;
◊using Azoth.Tools.Bootstrap.Compiler.CST.Conversions;
◊using Azoth.Tools.Bootstrap.Compiler.CST.Semantics;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Tokens;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Bare;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.ConstValue;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

Concrete = Span:`TextSpan`;
CompilationUnit = File:`CodeFile` ImplicitNamespaceName:`NamespaceName` Diagnostics:`Diagnostic`*
    UsingDirectives:UsingDirective* Definitions:NonMemberDefinition*;
UsingDirective = Name:`NamespaceName`;

// ---------- Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause = DataType:`IPromise<DataType?>`;

// ---------- Bindings
Binding = IsMutableBinding:`bool` Symbol:`IPromise<BindingSymbol>`;
LocalBinding: Binding = Symbol:`IPromise<NamedBindingSymbol>`;

// ---------- Definitions
Definition: Concrete <: `IHasContainingLexicalScope` = File:`CodeFile` Name:`TypeName`? NameSpan:`TextSpan` Symbol:`IPromise<Symbol>`;
EntityDefinition: Definition = AccessModifier:`IAccessModifierToken`?;
InvocableDefinition: EntityDefinition = Parameters:ConstructorOrInitializerParameter* Symbol:`IPromise<InvocableSymbol>`;
ConcreteInvocableDefinition: InvocableDefinition = Parameters:ConstructorOrInitializerParameter* Body;

// ---------- Namespace Definitions
NonMemberDefinition: Definition = ContainingNamespaceName:`NamespaceName`;
NamespaceDefinition: NonMemberDefinition = IsGlobalQualified:`bool` DeclaredNames:`NamespaceName` FullName:`NamespaceName` Symbol:`Promise<NamespaceSymbol>` UsingDirectives:UsingDirective* Definitions:NonMemberDefinition*;

// ---------- Function Definition
FunctionDefinition: NonMemberEntityDefinition <: ConcreteInvocableDefinition = Attributes:Attribute* Name:`IdentifierName` Parameters:NamedParameter* Return? Body Symbol:`AcyclicPromise<FunctionSymbol>`;

// ---------- Type Definitions
NonMemberEntityDefinition: EntityDefinition <: NonMemberDefinition = Name:`TypeName`;
TypeDefinition <: NonMemberEntityDefinition, ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition
    = ConstModifier:`IConstKeywordToken`? IsConst:`bool` MoveModifier:`IMoveKeywordToken`? IsMove:`bool` Name:`StandardName` GenericParameters:GenericParameter* Symbol:`AcyclicPromise<UserTypeSymbol>` SupertypeNames:StandardTypeName* Members:TypeMemberDefinition*;
ClassOrStructDefinition: TypeDefinition;
ClassDefinition: ClassOrStructDefinition = AbstractModifier:`IAbstractKeywordToken`? IsAbstract:`bool` GenericParameters:GenericParameter* BaseTypeName:StandardTypeName? SupertypeNames:StandardTypeName* DefaultConstructorSymbol:`ConstructorSymbol`? Members:ClassMemberDefinition*;
StructDefinition: ClassOrStructDefinition = GenericParameters:GenericParameter* SupertypeNames:StandardTypeName* DefaultInitializerSymbol:`InitializerSymbol`? Members:StructMemberDefinition*;
TraitDefinition: TypeDefinition = GenericParameters:GenericParameter* SupertypeNames:StandardTypeName* Members:TraitMemberDefinition*;

// ---------- Type Definition Parts
GenericParameter = Constraint:CapabilityConstraint Name:`IdentifierName` Independence:`ParameterIndependence` Variance:`ParameterVariance` Symbol:`Promise<GenericParameterTypeSymbol>`;

// ---------- Type Member Definitions (i.e. declarations that can be contained in a type)
// Note: by declaring the DefiningType property type with quotes, it avoids the system assuming it must represent a child syntax node
TypeMemberDefinition: EntityDefinition = DefiningType:`ITypeDefinitionSyntax`?;
ClassMemberDefinition: TypeMemberDefinition;
TraitMemberDefinition: TypeMemberDefinition;
StructMemberDefinition: TypeMemberDefinition;
AlwaysTypeMemberDefinition: TypeMemberDefinition = DefiningType:`ITypeDefinitionSyntax`;

// ---------- Member Definitions
MethodDefinition: AlwaysTypeMemberDefinition <: ClassMemberDefinition, TraitMemberDefinition, InvocableDefinition
    = Kind:`MethodKind` Name:`IdentifierName` SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Symbol:`AcyclicPromise<MethodSymbol>`;
AbstractMethodDefinition: MethodDefinition = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return?;
ConcreteMethodDefinition: MethodDefinition <: StructMemberDefinition, ConcreteInvocableDefinition
    = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Body;
StandardMethodDefinition: ConcreteMethodDefinition = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Body;
GetterMethodDefinition: ConcreteMethodDefinition = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return Body;
SetterMethodDefinition: ConcreteMethodDefinition = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Body;
ConstructorDefinition: ConcreteInvocableDefinition <: AlwaysTypeMemberDefinition, ClassMemberDefinition
    = DefiningType:`IClassDefinitionSyntax` Name:`IdentifierName`? SelfParameter:ConstructorSelfParameter Parameters:ConstructorOrInitializerParameter* Body:BlockBody Symbol:`AcyclicPromise<ConstructorSymbol>`;
InitializerDefinition: ConcreteInvocableDefinition <: AlwaysTypeMemberDefinition, StructMemberDefinition
    = DefiningType:`IStructDefinitionSyntax` Name:`IdentifierName`? SelfParameter:InitializerSelfParameter Parameters:ConstructorOrInitializerParameter* Body:BlockBody Symbol:`AcyclicPromise<InitializerSymbol>`;
FieldDefinition: AlwaysTypeMemberDefinition <: ClassMemberDefinition, StructMemberDefinition, Binding
    = DefiningType:`IClassOrStructDefinitionSyntax` Name:`IdentifierName` Type Symbol:`AcyclicPromise<FieldSymbol>` Initializer:Expression?;
AssociatedFunctionDefinition: AlwaysTypeMemberDefinition <: ClassMemberDefinition, TraitMemberDefinition, StructMemberDefinition, ConcreteInvocableDefinition
    = Name:`IdentifierName` Parameters:NamedParameter* Return? Body Symbol:`AcyclicPromise<FunctionSymbol>`;

// ---------- Attributes
Attribute = TypeName:StandardTypeName;

// ---------- Capabilities
CapabilityConstraint = Constraint:`ICapabilityConstraint`;
CapabilitySet: CapabilityConstraint = Constraint:`CapabilitySet`;
Capability: CapabilityConstraint = Tokens:`ICapabilityToken`* Declared:`DeclaredCapability` Capability:`Capability`;

// ---------- Parameters and Return
Parameter = Name:`IdentifierName`? DataType:`IPromise<Pseudotype>` Unused:`bool`;
/// A non-self parameter that can be declared in a constructor
ConstructorOrInitializerParameter: Parameter;
NamedParameter: ConstructorOrInitializerParameter <: LocalBinding = IsMutableBinding:`bool` IsLentBinding:`bool` Name:`IdentifierName` DeclarationNumber:`Promise<int?>` Type DataType:`IPromise<DataType>` Symbol:`Promise<NamedVariableSymbol>` DefaultValue:Expression?;
SelfParameter: Parameter = IsLentBinding:`bool` Symbol:`Promise<SelfParameterSymbol>`;
ConstructorSelfParameter: SelfParameter = IsLentBinding:`bool` Capability DataType:`IPromise<DataType>` Symbol:`Promise<SelfParameterSymbol>`;
InitializerSelfParameter: SelfParameter = IsLentBinding:`bool` Capability DataType:`IPromise<DataType>` Symbol:`Promise<SelfParameterSymbol>`;
MethodSelfParameter: SelfParameter = IsLentBinding:`bool` Capability:CapabilityConstraint Symbol:`Promise<SelfParameterSymbol>`;
FieldParameter: ConstructorOrInitializerParameter = Name:`IdentifierName` ReferencedSymbol:`Promise<FieldSymbol?>` DefaultValue:Expression?;
Return = Type; // Return type of a function or method

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body = Statements:BodyStatement*;
ExpressionBody: Body = ResultStatement Statements:Statement*;

// ---------- Types
Type;
TypeName: Type = Name:`TypeName` ReferencedSymbol:`Promise<TypeSymbol?>`;
StandardTypeName: TypeName = Name:`StandardName` NamedBareType:`BareReferenceType`?;
SimpleTypeName: TypeName;
IdentifierTypeName: TypeName <: StandardTypeName, SimpleTypeName = Name:`IdentifierName`;
SpecialTypeName: SimpleTypeName = Name:`SpecialTypeName`;
GenericTypeName: StandardTypeName =  Name:`GenericName` TypeArguments:Type*;
QualifiedTypeName: TypeName = Context:TypeName QualifiedName:StandardTypeName;
OptionalType: Type = Referent:Type;
CapabilityType: Type = Capability Referent:Type;
FunctionType: Type = Parameters:ParameterType* Return:ReturnType;
ParameterType = IsLent:`bool` Referent:Type;
ReturnType = Referent:Type; // Return type of function type
ViewpointType: Type = Referent:Type;
CapabilityViewpointType: ViewpointType = Capability Referent:Type;
SelfViewpointType: ViewpointType = ReferencedSymbol:`Promise<SelfParameterSymbol?>` Referent:Type;

// ---------- Statements
Statement;
ResultStatement: Statement <: BlockOrResult = Expression;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement <: LocalBinding = NameSpan:`TextSpan` Name:`IdentifierName` DeclarationNumber:`Promise<int?>` Capability? Type? Symbol:`Promise<NamedVariableSymbol>` Initializer:Expression?;
ExpressionStatement: BodyStatement = Expression;

// ---------- Patterns
Pattern;
BindingContextPattern: Pattern = IsMutableBinding:`bool` Pattern Type?;
OptionalOrBindingPattern: Pattern;
BindingPattern: OptionalOrBindingPattern <: LocalBinding = Name:`IdentifierName` DeclarationNumber:`Promise<int?>` Symbol:`Promise<NamedVariableSymbol>`;
OptionalPattern: OptionalOrBindingPattern = Pattern:OptionalOrBindingPattern;

// ---------- Expressions
Expression = DataType:`IPromise<DataType?>` ImplicitConversion:`Conversion` ConvertedDataType:`DataType`?;
TypedExpression: Expression = DataType:`IPromise<DataType>`;
DataTypedExpression: TypedExpression = DataType:`Promise<DataType>`;
AssignableExpression: TypedExpression = ReferencedSymbol:`IPromise<Symbol?>`;
BlockExpression: DataTypedExpression <: BlockOrResult, BodyOrBlock = Statements:Statement* DataType:`Promise<DataType>`;
NewObjectExpression: DataTypedExpression = Type:TypeName ConstructorName:`IdentifierName`? ConstructorNameSpan:`TextSpan`? Arguments:Expression* ReferencedSymbol:`Promise<ConstructorSymbol?>`;
UnsafeExpression: DataTypedExpression = Expression;
NeverTypedExpression: TypedExpression = DataType:`Promise<NeverType>`;

// ---------- Literal Expressions
LiteralExpression: TypedExpression;
BoolLiteralExpression: LiteralExpression = Value:`bool` DataType:`Promise<BoolConstValueType>`;
IntegerLiteralExpression: LiteralExpression = Value:`BigInteger` DataType:`Promise<IntegerConstValueType>`;
NoneLiteralExpression: LiteralExpression = DataType:`Promise<OptionalType>`;
StringLiteralExpression: LiteralExpression = Value:`string` DataType:`Promise<DataType>`;

// ---------- Operator Expressions
AssignmentExpression: DataTypedExpression = LeftOperand:AssignableExpression Operator:`AssignmentOperator` RightOperand:Expression;
BinaryOperatorExpression: DataTypedExpression = LeftOperand:Expression Operator:`BinaryOperator` RightOperand:Expression;
UnaryOperatorExpression: DataTypedExpression = Fixity:`UnaryOperatorFixity` Operator:`UnaryOperator` Operand:Expression;
IdExpression: DataTypedExpression = Referent:Expression;
ConversionExpression: DataTypedExpression = Referent:Expression Operator:`ConversionOperator` ConvertToType:Type;
PatternMatchExpression: DataTypedExpression = Referent:Expression Pattern;

// ---------- Control Flow Expressions
IfExpression: DataTypedExpression <: ElseClause = Condition:Expression ThenBlock:BlockOrResult ElseClause?;
LoopExpression: DataTypedExpression = Block:BlockExpression;
WhileExpression: DataTypedExpression = Condition:Expression Block:BlockExpression;
ForeachExpression: DataTypedExpression <: LocalBinding = VariableName:`IdentifierName` DeclarationNumber:`Promise<int?>` InExpression:Expression IterateMethod:`Promise<MethodSymbol?>` NextMethod:`Promise<MethodSymbol>` Type? Symbol:`Promise<NamedVariableSymbol>` Block:BlockExpression;
BreakExpression: NeverTypedExpression = Value:Expression?;
NextExpression: NeverTypedExpression;
ReturnExpression: NeverTypedExpression = Value:Expression?;

// ---------- Invocation Expressions
InvocationExpression: DataTypedExpression <: `IHasContainingLexicalScope` = Expression Arguments:Expression* ReferencedSymbol:`Promise<Symbol?>`;

// ---------- Name Expressions
NameExpression: Expression = Semantics:`IPromise<ISyntaxSemantics>` ReferencedSymbol:`IPromise<Symbol?>`;
SimpleName: NameExpression = Semantics:`IPromise<ISimpleNameExpressionSyntaxSemantics>`;
StandardNameExpression: NameExpression <: `IHasContainingLexicalScope` = Name:`StandardName`? ReferencedSymbol:`IPromise<Symbol?>`;
IdentifierNameExpression: NameExpression <: StandardNameExpression, SimpleName, AssignableExpression = Name:`IdentifierName`? Semantics:`Promise<IIdentifierNameExpressionSyntaxSemantics>`;
SpecialTypeNameExpression: NameExpression <: TypedExpression = Name:`SpecialTypeName` Semantics:`Promise<SpecialTypeNameExpressionSyntaxSemantics>` DataType:`Promise<DataType?>` ReferencedSymbol:`Promise<TypeSymbol?>`;
GenericNameExpression: NameExpression <: StandardNameExpression = Name:`GenericName` TypeArguments:Type* DataType:`Promise<DataType?>`;
InstanceExpression <: SimpleName, TypedExpression; // i.e. `self` or `base`
SelfExpression: NameExpression <: InstanceExpression = IsImplicit:`bool` Semantics:`Promise<ISelfExpressionSyntaxSemantics>` ReferencedSymbol:`IPromise<SelfParameterSymbol?>` Pseudotype:`IPromise<Pseudotype>`;
MemberAccessExpression: NameExpression <: AssignableExpression
    = Context:Expression MemberName:`StandardName` TypeArguments:Type* MemberNameSpan:`TextSpan`
    Semantics:`Promise<IMemberAccessSyntaxSemantics>` ReferencedSymbol:`IPromise<Symbol?>`;

// ---------- Capability Expressions
MoveExpression: DataTypedExpression = Referent:SimpleName ReferencedSymbol:`Promise<BindingSymbol?>`;
FreezeExpression: DataTypedExpression = Referent:SimpleName ReferencedSymbol:`Promise<BindingSymbol?>`;

// ---------- Async Expressions
AsyncBlockExpression: DataTypedExpression = Block:BlockExpression;
AsyncStartExpression: DataTypedExpression = Scheduled:`bool` Expression;
AwaitExpression: DataTypedExpression = Expression;
