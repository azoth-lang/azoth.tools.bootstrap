◊namespace Azoth.Tools.Bootstrap.Compiler.CST;
◊walkers_namespace Azoth.Tools.Bootstrap.Compiler.CST.Walkers;
◊base 'ISyntax';
◊prefix I;
◊suffix Syntax;
◊list IFixedList;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Promises;
◊using Azoth.Tools.Bootstrap.Compiler.CST.Conversions;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Tokens;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Capabilities;
◊using Azoth.Tools.Bootstrap.Compiler.Types.Pseudotypes;
◊using Azoth.Tools.Bootstrap.Framework;

'ISyntax' = Span:'TextSpan';
CompilationUnit = File:'CodeFile' ImplicitNamespaceName:'NamespaceName' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration* Diagnostics:'Diagnostic'*;
UsingDirective = Name:'NamespaceName';

// ---------- Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding = IsMutableBinding:'bool' Symbol:'IPromise<BindingSymbol>';
LocalBinding: Binding = Symbol:'IPromise<NamedBindingSymbol>';

// ---------- Declarations
Declaration: 'ISyntax', 'IHasContainingLexicalScope' = File:'CodeFile' Name:'TypeName'? NameSpan:'TextSpan' Symbol:'IPromise<Symbol>';
EntityDeclaration: Declaration = AccessModifier:'IAccessModifierToken'?;
InvocableDeclaration: EntityDeclaration = Parameters:ConstructorParameter* Symbol:'IPromise<InvocableSymbol>';
ConcreteInvocableDeclaration: InvocableDeclaration = Body;

// ---------- Non-Member Declarations
NonMemberDeclaration: Declaration = ContainingNamespaceName:'NamespaceName' Name:'TypeName';
// TODO if a compound namespace declaration was actually mutiple declarations, it would simplify other things
NamespaceDeclaration: NonMemberDeclaration = IsGlobalQualified:'bool' DeclaredNames:'NamespaceName' FullName:'NamespaceName' Symbol:'Promise<NamespaceOrPackageSymbol>' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration*;

// ---------- Non-Member Entity Declarations
NonMemberEntityDeclaration: EntityDeclaration, NonMemberDeclaration = Name:'TypeName';
TypeDeclaration: NonMemberEntityDeclaration = ConstModifier:'IConstKeywordToken'? IsConst:'bool' MoveModifier:'IMoveKeywordToken'? IsMove:'bool' Name:'StandardTypeName' GenericParameters:GenericParameter* Symbol:'AcyclicPromise<ObjectTypeSymbol>' SupertypeNames:TypeName* Members:MemberDeclaration*;
ClassDeclaration: TypeDeclaration = AbstractModifier:'IAbstractKeywordToken'? IsAbstract:'bool' GenericParameters:GenericParameter* BaseTypeName:TypeName? SupertypeNames:TypeName* DefaultConstructorSymbol:'ConstructorSymbol'? Members:ClassMemberDeclaration*;
TraitDeclaration: TypeDeclaration = GenericParameters:GenericParameter* SupertypeNames:TypeName* Members:TraitMemberDeclaration*;
FunctionDeclaration: NonMemberEntityDeclaration, ConcreteInvocableDeclaration = Attributes:Attribute* Name:'SimpleName' Parameters:NamedParameter* Return? Body Symbol:'AcyclicPromise<FunctionSymbol>';

// ---------- Member Declarations
// Note: by declaring the DeclaringType property type with quotes, it avoids the system assuming it must represent a child syntax node
MemberDeclaration: EntityDeclaration = DeclaringType:'ITypeDeclarationSyntax';
ClassMemberDeclaration: MemberDeclaration;
TraitMemberDeclaration: MemberDeclaration;
MethodDeclaration: ClassMemberDeclaration, TraitMemberDeclaration, InvocableDeclaration = Name:'SimpleName' SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Symbol:'AcyclicPromise<MethodSymbol>';
AbstractMethodDeclaration: MethodDeclaration = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return?;
ConcreteMethodDeclaration: MethodDeclaration, ConcreteInvocableDeclaration = SelfParameter:MethodSelfParameter Parameters:NamedParameter* Return? Body;
ConstructorDeclaration: ClassMemberDeclaration, ConcreteInvocableDeclaration = DeclaringType:'IClassDeclarationSyntax' Name:'SimpleName'? SelfParameter:ConstructorSelfParameter Parameters:ConstructorParameter* Body:BlockBody Symbol:'AcyclicPromise<ConstructorSymbol>';
FieldDeclaration: ClassMemberDeclaration, Binding = DeclaringType:'IClassDeclarationSyntax' Name:'SimpleName' Type Symbol:'AcyclicPromise<FieldSymbol>' Initializer:Expression?;
AssociatedFunctionDeclaration: ClassMemberDeclaration, TraitMemberDeclaration, ConcreteInvocableDeclaration = Name:'SimpleName' Parameters:NamedParameter* Return? Body Symbol:'AcyclicPromise<FunctionSymbol>';

// ---------- Attributes
Attribute = TypeName;

// ---------- Type Parameters --------------
GenericParameter = Constraint:CapabilityConstraint Name:'SimpleName' ParameterVariance:'ParameterVariance' Symbol:'Promise<GenericParameterTypeSymbol>';

// ---------- Parameters and Return--------------
Parameter = Name:'SimpleName'? DataType:'IPromise<Pseudotype>' Unused:'bool';
/// A non-self parameter that can be declared in a constructor
ConstructorParameter: Parameter;
NamedParameter: Parameter, ConstructorParameter, LocalBinding = IsMutableBinding:'bool' IsLentBinding:'bool' Name:'SimpleName' DeclarationNumber:'Promise<int?>' Type DataType:'IPromise<DataType>' Symbol:'Promise<VariableSymbol>' DefaultValue:Expression?;
SelfParameter: Parameter = IsLentBinding:'bool' Symbol:'Promise<SelfParameterSymbol>';
ConstructorSelfParameter: SelfParameter = IsLentBinding:'bool' Capability DataType:'IPromise<DataType>' Symbol:'Promise<SelfParameterSymbol>';
MethodSelfParameter: SelfParameter = IsLentBinding:'bool' Capability:CapabilityConstraint Symbol:'Promise<SelfParameterSymbol>';
CapabilityConstraint = Constraint:'ICapabilityConstraint';
CapabilitySet: CapabilityConstraint = Constraint:'CapabilitySet';
FieldParameter: Parameter, ConstructorParameter = Name:'SimpleName' ReferencedSymbol:'Promise<FieldSymbol?>' DefaultValue:Expression?;
Return = Type; // Return type of a function or method

// ---------- Function Parts
Body: BodyOrBlock;
BlockBody: Body = Statements:BodyStatement*;
ExpressionBody: Body = ResultStatement Statements:Statement*;

// ---------- Types
Type;
TypeName: Type, 'IHasContainingLexicalScope' = Name:'TypeName' ReferencedSymbol:'Promise<TypeSymbol?>';
SimpleTypeName: TypeName = ReferencedSymbol:'Promise<TypeSymbol?>';
ParameterizedType: TypeName = TypeArguments:Type* ReferencedSymbol:'Promise<TypeSymbol?>';
// TODO QualifiedTypeName
OptionalType: Type = Referent:Type;
CapabilityType: Type = Capability Referent:Type;
Capability: CapabilityConstraint = Tokens:'ICapabilityToken'* Declared:'DeclaredCapability' Capability:'Capability';
FunctionType: Type = Parameters:ParameterType* Return:ReturnType;
ParameterType = IsLent:'bool' Referent:Type;
ReturnType = Referent:Type; // Return type of function type
ViewpointType: Type = Referent:Type;
CapabilityViewpointType: ViewpointType = Capability Referent:Type;
SelfViewpointType: ViewpointType = ReferencedSymbol:'Promise<SelfParameterSymbol?>' Referent:Type;

// ---------- Statements
Statement;
ResultStatement: Statement, BlockOrResult = Expression;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement, LocalBinding = NameSpan:'TextSpan' Name:'SimpleName' DeclarationNumber:'Promise<int?>' Capability? Type? Symbol:'Promise<VariableSymbol>' Initializer:Expression?;
ExpressionStatement: BodyStatement = Expression;

// ---------- Patterns
Pattern;
BindingContextPattern: Pattern = IsMutableBinding:'bool' Pattern Type?;
OptionalOrBindingPattern: Pattern;
BindingPattern: OptionalOrBindingPattern, LocalBinding = Name:'SimpleName' DeclarationNumber:'Promise<int?>' Symbol:'Promise<VariableSymbol>';
OptionalPattern: OptionalOrBindingPattern = Pattern:OptionalOrBindingPattern;

// ---------- Expressions
Expression = ImplicitConversion:'Conversion' ConvertedDataType:'DataType'? ConvertedSemantics:'ExpressionSemantics'?;
AssignableExpression: Expression;
BlockExpression: Expression, BlockOrResult, BodyOrBlock = Statements:Statement*;
NewObjectExpression: Expression = Type:TypeName ConstructorName:'SimpleName'? ConstructorNameSpan:'TextSpan'? Arguments:Expression* ReferencedSymbol:'Promise<ConstructorSymbol?>';
UnsafeExpression: Expression = Expression;

// ---------- Literal Expressions
LiteralExpression: Expression;
BoolLiteralExpression: LiteralExpression = Value:'bool';
IntegerLiteralExpression: LiteralExpression = Value:'BigInteger';
NoneLiteralExpression: LiteralExpression;
StringLiteralExpression: LiteralExpression = Value:'string';

// ---------- Operator Expressions
AssignmentExpression: Expression = LeftOperand:AssignableExpression Operator:'AssignmentOperator' RightOperand:Expression;
BinaryOperatorExpression: Expression = LeftOperand:Expression Operator:'BinaryOperator' RightOperand:Expression;
UnaryOperatorExpression: Expression = Fixity:'UnaryOperatorFixity' Operator:'UnaryOperator' Operand:Expression;
IdExpression: Expression = Referent:Expression;
ConversionExpression: Expression = Referent:Expression Operator:'ConversionOperator' ConvertToType:Type;
PatternMatchExpression: Expression = Referent:Expression Pattern;

// ---------- Control Flow Expressions
IfExpression: Expression, ElseClause = Condition:Expression ThenBlock:BlockOrResult ElseClause?;
LoopExpression: Expression = Block:BlockExpression;
WhileExpression: Expression = Condition:Expression Block:BlockExpression;
ForeachExpression: Expression, LocalBinding = VariableName:'SimpleName' DeclarationNumber:'Promise<int?>' InExpression:Expression IterateMethod:'Promise<MethodSymbol?>' NextMethod:'Promise<MethodSymbol>' Type? Symbol:'Promise<VariableSymbol>' Block:BlockExpression;
BreakExpression: Expression = Value:Expression?;
NextExpression: Expression;
ReturnExpression: Expression = Value:Expression?;

// ---------- Invocation Expressions
InvocationExpression: Expression, 'IHasContainingLexicalScope' = Expression Arguments:Expression* ReferencedSymbol:'Promise<Symbol?>';

// ---------- Variable Expressions
NameExpression: AssignableExpression = ReferencedSymbol:'Promise<Symbol?>';
VariableNameExpression: Expression = ReferencedSymbol:'IPromise<Symbol?>';
SimpleNameExpression: NameExpression, VariableNameExpression, 'IHasContainingLexicalScope' = Name:'SimpleName'? ReferencedSymbol:'Promise<Symbol?>';
SelfExpression: VariableNameExpression = IsImplicit:'bool' ReferencedSymbol:'Promise<SelfParameterSymbol?>';
QualifiedNameExpression: NameExpression = Context:Expression AccessOperator:'AccessOperator' Member:SimpleNameExpression;

// ---------- Capability Expressions
MoveExpression: Expression = Referent:VariableNameExpression ReferencedSymbol:'Promise<BindingSymbol?>';
FreezeExpression: Expression = Referent:VariableNameExpression ReferencedSymbol:'Promise<BindingSymbol?>';

// ---------- Async Expressions
AsyncBlockExpression: Expression = Block:BlockExpression;
AsyncStartExpression: Expression = Scheduled:'bool' Expression;
AwaitExpression: Expression = Expression;
