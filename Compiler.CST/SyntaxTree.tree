◊namespace Azoth.Tools.Bootstrap.Compiler.CST;
◊walkers_namespace Azoth.Tools.Bootstrap.Compiler.CST.Walkers;
◊base 'ISyntax';
◊prefix I;
◊suffix Syntax;
◊list FixedList;
◊using System.Numerics;
◊using Azoth.Tools.Bootstrap.Compiler.Core;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Operators;
◊using Azoth.Tools.Bootstrap.Compiler.Core.Promises;
◊using Azoth.Tools.Bootstrap.Compiler.CST.Conversions;
◊using Azoth.Tools.Bootstrap.Compiler.Names;
◊using Azoth.Tools.Bootstrap.Compiler.Symbols;
◊using Azoth.Tools.Bootstrap.Compiler.Tokens;
◊using Azoth.Tools.Bootstrap.Compiler.Types;
◊using Azoth.Tools.Bootstrap.Framework;

'ISyntax' = Span:'TextSpan';
CompilationUnit = File:'CodeFile' ImplicitNamespaceName:'NamespaceName' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration* Diagnostics:'Diagnostic'*;
UsingDirective = Name:'NamespaceName';

// ---------- Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause;

// ---------- Bindings
Binding = IsMutableBinding:'bool' Symbol:'IPromise<BindingSymbol>';
LocalBinding: Binding = Symbol:'IPromise<NamedBindingSymbol>';

// ---------- Declarations
Declaration: 'ISyntax', 'IHasContainingLexicalScope' = File:'CodeFile' Name:'Name'? NameSpan:'TextSpan' Symbol:'IPromise<Symbol>';
EntityDeclaration: Declaration = AccessModifier:'IAccessModifierToken'?;
InvocableDeclaration: EntityDeclaration = Parameters:ConstructorParameter* Symbol:'IPromise<InvocableSymbol>';
ConcreteInvocableDeclaration: InvocableDeclaration = Body;

// ---------- Non-Member Declarations
NonMemberDeclaration: Declaration = ContainingNamespaceName:'NamespaceName' Name:'Name';
// TODO if a compound namespace declaration was actually mutiple declarations, it would simplify other things
NamespaceDeclaration: NonMemberDeclaration = IsGlobalQualified:'bool' DeclaredNames:'NamespaceName' FullName:'NamespaceName' Symbol:'Promise<NamespaceOrPackageSymbol>' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration*;

// ---------- Non-Member Entity Declarations
NonMemberEntityDeclaration: EntityDeclaration, NonMemberDeclaration = Name:'Name';
ClassDeclaration: NonMemberEntityDeclaration = ConstModifier:'IConstKeywordToken'? IsConst:'bool' MoveModifier:'IMoveKeywordToken'? IsMove:'bool' Name:'Name' Symbol:'AcyclicPromise<ObjectTypeSymbol>' Members:MemberDeclaration* DefaultConstructorSymbol:'ConstructorSymbol'?;
FunctionDeclaration: NonMemberEntityDeclaration, ConcreteInvocableDeclaration = Name:'Name' Parameters:NamedParameter* ReturnType:Type? Body Symbol:'AcyclicPromise<FunctionSymbol>';

// ---------- Member Declarations
// Note: by declaring the DeclaringClass property type with quotes, it avoids the system assuming it must represent a child syntax node
MemberDeclaration: EntityDeclaration = DeclaringClass:'IClassDeclarationSyntax';
MethodDeclaration: MemberDeclaration, InvocableDeclaration = Name:'Name' SelfParameter Parameters:NamedParameter* ReturnType:Type? Symbol:'AcyclicPromise<MethodSymbol>';
AbstractMethodDeclaration: MethodDeclaration = SelfParameter Parameters:NamedParameter* ReturnType:Type?;
ConcreteMethodDeclaration: MethodDeclaration, ConcreteInvocableDeclaration = SelfParameter Parameters:NamedParameter* ReturnType:Type? Body;
ConstructorDeclaration: MemberDeclaration, ConcreteInvocableDeclaration = ImplicitSelfParameter:SelfParameter Parameters:ConstructorParameter* Body Symbol:'AcyclicPromise<ConstructorSymbol>';
FieldDeclaration: MemberDeclaration, Binding = Name:'Name' Type Symbol:'AcyclicPromise<FieldSymbol>' Initializer:Expression?;
AssociatedFunctionDeclaration: MemberDeclaration, ConcreteInvocableDeclaration = Name:'Name' Parameters:NamedParameter* ReturnType:Type? Body Symbol:'AcyclicPromise<FunctionSymbol>';

// ---------- Parameters --------------
Parameter = Name:'Name'? DataType:'IPromise<DataType>' Unused:'bool';
/// A parameter that can be declared in a constructor
ConstructorParameter: Parameter;
/// A parameter that creates a binding, i.e. a named or self parameter
BindingParameter: Parameter, Binding;
NamedParameter: Parameter, ConstructorParameter, BindingParameter, LocalBinding = Name:'Name' DeclarationNumber:'Promise<int?>' Type Symbol:'Promise<VariableSymbol>' DefaultValue:Expression?;
SelfParameter: Parameter, BindingParameter = Capability:ReferenceCapability Symbol:'Promise<SelfParameterSymbol>';
FieldParameter: Parameter, ConstructorParameter = ReferencedSymbol:'Promise<FieldSymbol?>' DefaultValue:Expression?;

// ---------- Function Parts
Body: BodyOrBlock = Statements:BodyStatement*;

// ---------- Types
Type;
TypeName: Type, 'IHasContainingLexicalScope' = Name:'TypeName' ReferencedSymbol:'Promise<TypeSymbol?>';
SimpleTypeName: TypeName = Name:'TypeName' ReferencedSymbol:'Promise<TypeSymbol?>';
OptionalType: Type = Referent:Type;
CapabilityType: Type = Capability:ReferenceCapability ReferentType:Type;
ReferenceCapability = Tokens:'ICapabilityToken'* Declared:'DeclaredReferenceCapability';

// ---------- Statements
Statement;
ResultStatement: Statement, BlockOrResult = Expression;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement, LocalBinding = NameSpan:'TextSpan' Name:'Name' DeclarationNumber:'Promise<int?>' Capability:ReferenceCapability? Type? Symbol:'Promise<VariableSymbol>' Initializer:Expression?;
ExpressionStatement: BodyStatement = Expression;

// ---------- Expressions
Expression = ImplicitConversion:'Conversion' ConvertedDataType:'DataType'? ConvertedSemantics:'ExpressionSemantics'?;
AssignableExpression: Expression;
BlockExpression: Expression, BlockOrResult, BodyOrBlock = Statements:Statement*;
NewObjectExpression: Expression = Type:TypeName ConstructorName:'Name'? ConstructorNameSpan:'TextSpan'? Arguments:Expression* ReferencedSymbol:'Promise<ConstructorSymbol?>';
UnsafeExpression: Expression = Expression;

// ---------- Literal Expressions
LiteralExpression: Expression;
BoolLiteralExpression: LiteralExpression = Value:'bool';
IntegerLiteralExpression: LiteralExpression = Value:'BigInteger';
NoneLiteralExpression: LiteralExpression;
StringLiteralExpression: LiteralExpression = Value:'string';

// ---------- Operator Expressions
AssignmentExpression: Expression = LeftOperand:AssignableExpression Operator:'AssignmentOperator' RightOperand:Expression;
BinaryOperatorExpression: Expression = LeftOperand:Expression Operator:'BinaryOperator' RightOperand:Expression;
UnaryOperatorExpression: Expression = Fixity:'UnaryOperatorFixity' Operator:'UnaryOperator' Operand:Expression;
IdExpression: Expression = Referent:Expression;
ConversionExpression: Expression = Referent:Expression ConvertToType:Type?;

// ---------- Control Flow Expressions
IfExpression: Expression, ElseClause = Condition:Expression ThenBlock:BlockOrResult ElseClause?;
LoopExpression: Expression = Block:BlockExpression;
WhileExpression: Expression = Condition:Expression Block:BlockExpression;
ForeachExpression: Expression, LocalBinding = VariableName:'Name' DeclarationNumber:'Promise<int?>' InExpression:Expression Type? Symbol:'Promise<VariableSymbol>' Block:BlockExpression;
BreakExpression: Expression = Value:Expression?;
NextExpression: Expression;
ReturnExpression: Expression = Value:Expression?;

// ---------- Invocation Expressions
InvocationExpression: Expression, 'IHasContainingLexicalScope' = Expression Arguments:Expression* ReferencedSymbol:'Promise<InvocableSymbol?>';

// ---------- Variable Expressions
NameExpression: AssignableExpression = ReferencedSymbol:'Promise<Symbol?>';
SimpleNameExpression: NameExpression, 'IHasContainingLexicalScope' = Name:'Name'?;
SelfExpression: Expression = IsImplicit:'bool' ReferencedSymbol:'Promise<SelfParameterSymbol?>';
QualifiedNameExpression: NameExpression = Context:Expression AccessOperator:'AccessOperator' Member:SimpleNameExpression;

// ---------- Capability Expressions
MutateExpression: Expression = Referent:Expression ReferencedSymbol:'Promise<BindingSymbol?>';
MoveExpression: Expression = Referent:Expression ReferencedSymbol:'Promise<BindingSymbol?>';
FreezeExpression: Expression = Referent:Expression ReferencedSymbol:'Promise<BindingSymbol?>';
